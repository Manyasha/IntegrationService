{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 5eb2acf41dcebb729f39","webpack:///../~/extend/index.js","webpack:///./EventEmitter.js","webpack:///../~/js-logger/src/logger.js","webpack:///./IntegrationService.js","webpack:///./Chat.js","webpack:///./Roster.js","webpack:///./Telephony.js","webpack:///./Connector.js","webpack:///./index.js","webpack:///../~/reconnectingwebsocket/reconnecting-websocket.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;8CChEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACrFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;ACjFD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;;AAEf;AACA;;AAEA;AACA;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;;AAEA;AACA,0CAA0C,0BAA0B;;AAEpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa;AAChF;;AAEA;AACA,sDAAsD;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;AChQD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qCAAqC;;AAErC;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,CAAC;;;;;;;;ACzND;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA,kDAAkD;;AAElD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,CAAC;;;;;;;;AC1CD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA,oDAAoD;;AAEpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;ACzJD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA,uDAAuD;;AAEvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;AC3JD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,SAAS;AACnC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,CAAC;;;;;;;;ACpVD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uCAAuC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,cAAc;;AAErC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oEAAoE,oBAAoB,EAAE;AAC1F,oEAAoE,qBAAqB,EAAE;AAC3F,oEAAoE,0BAA0B,EAAE;AAChG,oEAAoE,uBAAuB,EAAE;AAC7F,oEAAoE,qBAAqB,EAAE;;AAE3F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC","file":"Wildix.IntegrationService.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"IntegrationService\"] = factory();\n\telse\n\t\troot[\"Wildix\"] = root[\"Wildix\"] || {}, root[\"Wildix\"][\"IntegrationService\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5eb2acf41dcebb729f39","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/extend/index.js\n// module id = 0\n// module chunks = 0 1","/**\n * @class EventEmitter\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory();\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define([], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof ReconnectingWebSocket !== 'undefined'){\n        // Browser\n        root.EventEmitter = factory();\n    }\n}(this, function (){\n    'use strict';\n    var EventEmitter = {\n        _handlers: null,\n\n        on: function(event, fn, scope) {\n            this._handlers = this._handlers || {};\n            if(typeof this._handlers[event] === 'undefined'){\n                this._handlers[event] = [];\n            }\n\n            this._handlers[event].push({\n                fn: fn,\n                scope: scope\n            });\n        },\n\n        off: function(event, fn) {\n            if(typeof this._handlers[event] === 'undefined'){\n                return true;\n            }\n\n            this._handlers[event] = this._handlers[event].filter(\n                function(item) {\n                    if (item.fn !== fn) {\n                        return item;\n                    }\n                }\n            );\n        },\n\n        trigger: function(event, param) {\n            // console.log('trigger', event, param)\n\n            var args = arguments;\n\n            if(!this._handlers || typeof this._handlers[event] === 'undefined'){\n                return;\n            }\n\n            var handlers = this._handlers[event];\n\n            for (var i = 0; i < handlers.length; i++) {\n                var handler = handlers[i];\n                if(handler.fn){\n                    switch (args.length) {\n                        // fast cases\n                        case 1:\n                            handler.fn.call(handler.scope, event);\n                            break;\n                        case 2:\n                            handler.fn.call(handler.scope, event, param);\n                            break;\n                        case 3:\n                            handler.fn.call(handler.scope, event, param, args[2]);\n                            break;\n                            // slower\n                        default:\n                            handler.fn.apply(handler.scope, args);\n                    }\n                }\n            }\n        }\n    };\n\n    return EventEmitter;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./EventEmitter.js\n// module id = 1\n// module chunks = 0 1","/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\r\n(function (global) {\r\n\t\"use strict\";\r\n\r\n\t// Top level module for the global, static logger instance.\r\n\tvar Logger = { };\r\n\r\n\t// For those that are at home that are keeping score.\r\n\tLogger.VERSION = \"1.3.0\";\r\n\r\n\t// Function which handles all incoming log messages.\r\n\tvar logHandler;\r\n\r\n\t// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\r\n\tvar contextualLoggersByNameMap = {};\r\n\r\n\t// Polyfill for ES5's Function.bind.\r\n\tvar bind = function(scope, func) {\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t// Super exciting object merger-matron 9000 adding another 100 bytes to your download.\r\n\tvar merge = function () {\r\n\t\tvar args = arguments, target = args[0], key, i;\r\n\t\tfor (i = 1; i < args.length; i++) {\r\n\t\t\tfor (key in args[i]) {\r\n\t\t\t\tif (!(key in target) && args[i].hasOwnProperty(key)) {\r\n\t\t\t\t\ttarget[key] = args[i][key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\t// Helper to define a logging level object; helps with optimisation.\r\n\tvar defineLogLevel = function(value, name) {\r\n\t\treturn { value: value, name: name };\r\n\t};\r\n\r\n\t// Predefined logging levels.\r\n\tLogger.DEBUG = defineLogLevel(1, 'DEBUG');\r\n\tLogger.INFO = defineLogLevel(2, 'INFO');\r\n\tLogger.TIME = defineLogLevel(3, 'TIME');\r\n\tLogger.WARN = defineLogLevel(4, 'WARN');\r\n\tLogger.ERROR = defineLogLevel(8, 'ERROR');\r\n\tLogger.OFF = defineLogLevel(99, 'OFF');\r\n\r\n\t// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\r\n\t// of each other.\r\n\tvar ContextualLogger = function(defaultContext) {\r\n\t\tthis.context = defaultContext;\r\n\t\tthis.setLevel(defaultContext.filterLevel);\r\n\t\tthis.log = this.info;  // Convenience alias.\r\n\t};\r\n\r\n\tContextualLogger.prototype = {\r\n\t\t// Changes the current logging level for the logging instance.\r\n\t\tsetLevel: function (newLevel) {\r\n\t\t\t// Ensure the supplied Level object looks valid.\r\n\t\t\tif (newLevel && \"value\" in newLevel) {\r\n\t\t\t\tthis.context.filterLevel = newLevel;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Is the logger configured to output messages at the supplied level?\r\n\t\tenabledFor: function (lvl) {\r\n\t\t\tvar filterLevel = this.context.filterLevel;\r\n\t\t\treturn lvl.value >= filterLevel.value;\r\n\t\t},\r\n\r\n\t\tdebug: function () {\r\n\t\t\tthis.invoke(Logger.DEBUG, arguments);\r\n\t\t},\r\n\r\n\t\tinfo: function () {\r\n\t\t\tthis.invoke(Logger.INFO, arguments);\r\n\t\t},\r\n\r\n\t\twarn: function () {\r\n\t\t\tthis.invoke(Logger.WARN, arguments);\r\n\t\t},\r\n\r\n\t\terror: function () {\r\n\t\t\tthis.invoke(Logger.ERROR, arguments);\r\n\t\t},\r\n\r\n\t\ttime: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'start' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttimeEnd: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'end' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Invokes the logger callback if it's not being filtered.\r\n\t\tinvoke: function (level, msgArgs) {\r\n\t\t\tif (logHandler && this.enabledFor(level)) {\r\n\t\t\t\tlogHandler(msgArgs, merge({ level: level }, this.context));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Protected instance which all calls to the to level `Logger` module will be routed through.\r\n\tvar globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });\r\n\r\n\t// Configure the global Logger instance.\r\n\t(function() {\r\n\t\t// Shortcut for optimisers.\r\n\t\tvar L = Logger;\r\n\r\n\t\tL.enabledFor = bind(globalLogger, globalLogger.enabledFor);\r\n\t\tL.debug = bind(globalLogger, globalLogger.debug);\r\n\t\tL.time = bind(globalLogger, globalLogger.time);\r\n\t\tL.timeEnd = bind(globalLogger, globalLogger.timeEnd);\r\n\t\tL.info = bind(globalLogger, globalLogger.info);\r\n\t\tL.warn = bind(globalLogger, globalLogger.warn);\r\n\t\tL.error = bind(globalLogger, globalLogger.error);\r\n\r\n\t\t// Don't forget the convenience alias!\r\n\t\tL.log = L.info;\r\n\t}());\r\n\r\n\t// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\r\n\t// object with the supplied log messages and the second being a context object which contains a hash of stateful\r\n\t// parameters which the logging function can consume.\r\n\tLogger.setHandler = function (func) {\r\n\t\tlogHandler = func;\r\n\t};\r\n\r\n\t// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\r\n\t// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\r\n\tLogger.setLevel = function(level) {\r\n\t\t// Set the globalLogger's level.\r\n\t\tglobalLogger.setLevel(level);\r\n\r\n\t\t// Apply this level to all registered contextual loggers.\r\n\t\tfor (var key in contextualLoggersByNameMap) {\r\n\t\t\tif (contextualLoggersByNameMap.hasOwnProperty(key)) {\r\n\t\t\t\tcontextualLoggersByNameMap[key].setLevel(level);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\r\n\t// default context and log handler.\r\n\tLogger.get = function (name) {\r\n\t\t// All logger instances are cached so they can be configured ahead of use.\r\n\t\treturn contextualLoggersByNameMap[name] ||\r\n\t\t\t(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));\r\n\t};\r\n\r\n\t// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\r\n\t// write to the window's console object (if present); the optional options object can be used to customise the\r\n\t// formatter used to format each log message.\r\n\tLogger.createDefaultHandler = function (options) {\r\n\t\toptions = options || {};\r\n\r\n\t\toptions.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\r\n\t\t\t// Prepend the logger's name to the log message for easy identification.\r\n\t\t\tif (context.name) {\r\n\t\t\t\tmessages.unshift(\"[\" + context.name + \"]\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\r\n\t\t// that don't offer a native console method.\r\n\t\tvar timerStartTimeByLabelMap = {};\r\n\r\n\t\t// Support for IE8+ (and other, slightly more sane environments)\r\n\t\tvar invokeConsoleMethod = function (hdlr, messages) {\r\n\t\t\tFunction.prototype.apply.call(hdlr, console, messages);\r\n\t\t};\r\n\r\n\t\t// Check for the presence of a logger.\r\n\t\tif (typeof console === \"undefined\") {\r\n\t\t\treturn function () { /* no console */ };\r\n\t\t}\r\n\r\n\t\treturn function(messages, context) {\r\n\t\t\t// Convert arguments object to Array.\r\n\t\t\tmessages = Array.prototype.slice.call(messages);\r\n\r\n\t\t\tvar hdlr = console.log;\r\n\t\t\tvar timerLabel;\r\n\r\n\t\t\tif (context.level === Logger.TIME) {\r\n\t\t\t\ttimerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\r\n\r\n\t\t\t\tif (messages[1] === 'start') {\r\n\t\t\t\t\tif (console.time) {\r\n\t\t\t\t\t\tconsole.time(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttimerStartTimeByLabelMap[timerLabel] = new Date().getTime();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (console.timeEnd) {\r\n\t\t\t\t\t\tconsole.timeEnd(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinvokeConsoleMethod(hdlr, [ timerLabel + ': ' +\r\n\t\t\t\t\t\t\t(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Delegate through to custom warn/error loggers if present on the console.\r\n\t\t\t\tif (context.level === Logger.WARN && console.warn) {\r\n\t\t\t\t\thdlr = console.warn;\r\n\t\t\t\t} else if (context.level === Logger.ERROR && console.error) {\r\n\t\t\t\t\thdlr = console.error;\r\n\t\t\t\t} else if (context.level === Logger.INFO && console.info) {\r\n\t\t\t\t\thdlr = console.info;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toptions.formatter(messages, context);\r\n\t\t\t\tinvokeConsoleMethod(hdlr, messages);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t// Configure and example a Default implementation which writes to the `window.console` (if present).  The\r\n\t// `options` hash can be used to configure the default logLevel and provide a custom message formatter.\r\n\tLogger.useDefaults = function(options) {\r\n\t\tLogger.setLevel(options && options.defaultLevel || Logger.DEBUG);\r\n\t\tLogger.setHandler(Logger.createDefaultHandler(options));\r\n\t};\r\n\r\n\t// Export to popular environments boilerplate.\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine(Logger);\r\n\t}\r\n\telse if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = Logger;\r\n\t}\r\n\telse {\r\n\t\tLogger._prevLogger = global.Logger;\r\n\r\n\t\tLogger.noConflict = function () {\r\n\t\t\tglobal.Logger = Logger._prevLogger;\r\n\t\t\treturn Logger;\r\n\t\t};\r\n\r\n\t\tglobal.Logger = Logger;\r\n\t}\r\n}(this));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/js-logger/src/logger.js\n// module id = 2\n// module chunks = 0 1","/**\n * @class IntegrationService\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('Logger'), require('EventEmitter'), require('Connector'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['Logger', 'EventEmitter', 'Connector'], factory);\n    } else if (typeof Logger !== 'undefined'){\n        // Browser\n        root.IntegrationService = factory(Logger, EventEmitter, Connector);\n    }\n}(this, function (Logger, EventEmitter, Connector){\n    'use strict';\n    // enable all logs\n    // Wildix.IntegrationService.Logger.setLevel(Wildix.IntegrationService.Logger.DEBUG)\n    // Logger.useDefaults();\n    // Logger.setLevel(Logger.WARN);  // Global logging level.\n    // Logger.setLevel(Logger.DEBUG);  // Global logging level.\n\n    var logger = Logger.get('IntegrationService');\n\n    function IntegrationService(options){\n        this.initialize(options);\n    }\n\n    IntegrationService.Logger = Logger;\n\n    IntegrationService.Modules = {};\n\n    IntegrationService.addModule = function(name, module){\n        IntegrationService.Modules[name] = module;\n    };\n\n    extend(IntegrationService.prototype, EventEmitter, {\n        _options: {\n            app: 'APP_WEBCRM',\n            name: 'WebCRM',\n            version: '0.0.1',\n            userAgent: navigator.userAgent,\n            platform: navigator.platform\n        },\n\n        _connectionOptions: {\n            debug: false,\n            automaticOpen: true,\n            reconnectInterval: 1000,\n            maxReconnectInterval: 5000,\n            reconnectDelay: 1,\n            timeoutInterval: 3000,\n            maxReconnectAttempts: 1\n        },\n\n        _connection: null,\n\n        _macComponentVersion: {\n            'wiservice': '2.5.0'\n        },\n\n        _winComponentVersion: {\n            'wiservice': '2.5.0'\n        },\n\n        _version: null,\n\n        initialize: function(options){\n            logger.info('Initialize Integration service', options);\n\n            extend(this._options, options);\n\n            this._options.app = 'APP_' + this._options.name.toUpperCase();\n\n            for (var key in IntegrationService.Modules) {\n                logger.info('Build module:', key);\n                if(typeof IntegrationService.Modules[key] === 'object'){\n                    var Module = function(){};\n                    Module.prototype = IntegrationService.Modules[key];\n\n                    this[key] = new Module();\n                    this[key].initialize(this);\n                }else{\n                    this[key] = new IntegrationService.Modules[key](this);\n                }\n            }\n\n            this.getConnection().on('ready', this._onReady, this);\n            this.getConnection().on('event:wiservice', this._onEventWiservice, this);\n            this.getConnection().on('message:' + this._options.app.toLowerCase(), this._onMessage, this);\n            this.getConnection().on('error', this._onConnectionError, this);\n        },\n\n        getConnection: function(port) {\n            if(this._connection === null){\n                this._connection = new Connector(this._connectionOptions);\n                this._connection.setAuthData(this._options);\n            }\n            return this._connection;\n        },\n\n        _ready: false,\n        isReady: function(){\n            return this._ready;\n        },\n\n        _onReady: function(){\n            this.getVersion();\n        },\n\n        _countCollaborationss: 0,\n        _onEventWiservice: function(event, data){\n            logger.info('_onEventWiservice', event, data);\n            if(data && data.msgdata){\n                if(data.msgdata.type == 'connectionstatus'){\n                    if(data.msgdata.disconnected && data.msgdata.disconnected.collaboration){\n                        // maybe disconnected\n                        if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                            // have another collaboration connection\n                        }else{\n                            this._collaborationStatus = 'disconnected';\n                            this.trigger('collaboration:' + this._collaborationStatus, this);\n                        }\n                    }else if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                        if(this._countCollaborations != data.msgdata.connected.collaboration.length){\n                            this._collaborationStatus = 'connected';\n                            this.trigger('collaboration:' + this._collaborationStatus, this);\n                        }\n                    }\n\n                    this._countCollaborations = 0;\n                    if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                        this._countCollaborations = data.msgdata.connected.collaboration.length;\n                    }\n                }\n            }\n        },\n\n        _onMessage: function(event, data){\n            this.trigger(data.msgdata.command, data.msgdata.msgdata);\n        },\n\n        _onConnectionError: function(){\n            this.trigger('connection:error', this);\n        },\n\n        refresh: function(){\n            this.getConnection().refresh();\n        },\n\n        open: function(){\n            this.getConnection().open();\n        },\n\n        isConnected: function(){\n            return this.getConnection().isConnected();\n        },\n\n        _collaborationStatus: null,\n        getCollaborationStatus: function(){\n            if(!this.isConnected()){\n                return null;\n            }\n            if(this._collaborationStatus === null){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'getconnectionstatus'\n                    }\n                };\n                this.getConnection().send(message, function(response){\n                    logger.info('collaboration status', response);\n                    var connected = response.connected || {};\n                    if(connected.collaboration && connected.collaboration.length > 0){\n                        this._collaborationStatus = 'connected';\n                        this._countCollaborations = response.connected.collaboration.length;\n                        this._ready = true;\n                        this.trigger('ready', this);\n                        this.trigger('collaboration:' + this._collaborationStatus, this);\n                    }\n                }.bind(this));\n            }\n            return this._collaborationStatus;\n        },\n\n        getVersion: function(name, force){\n            if(!this.isConnected()){\n                return null;\n            }\n\n            if(this._version === null || force){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'getversion'\n                    }\n                };\n                this.getConnection().send(message, function(response){\n                    if(response && response.wiservice){\n                        this._version = response;\n                        this.getCollaborationStatus();\n                    }\n                }.bind(this));\n            }\n\n            if(name){\n                if(this._version && this._version.hasOwnProperty(name) && this._version[name]){\n                    return this._version[name];\n                }\n                return null;\n            }\n            return this._version;\n        }\n    });\n\n    return IntegrationService;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./IntegrationService.js\n// module id = 3\n// module chunks = 0 1","/**\n * @class Chat\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('IntegrationService'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Chat');\n\n    IntegrationService.addModule('Chat', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n        },\n\n        open: function(number){\n            var message = {\n                'msgdata': {\n                    'type': 'chat',\n                    'number': number\n                }\n            };\n            this._connection.send(message);\n        }\n\n    }));\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Chat.js\n// module id = 4\n// module chunks = 0 1","/**\n * @class Roster\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('IntegrationService'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Roster');\n\n    IntegrationService.addModule('Roster', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n            this._integrationService.on('collaboration:connected', this._onConnectedCollaboration, this);\n        },\n\n        _bindEvents: function(){\n            logger.info('_bindEvents');\n            this._integrationService.on('setroster', this._onSetRoster, this);\n            this._integrationService.on('updateuser', this._onUpdateUser, this);\n            this._integrationService.on('removeuser', this._onRemoveUser, this);\n            this._integrationService.on('adduser', this._onAddUser, this);\n        },\n\n        _roster: null,\n\n        getRoster: function(){\n            return this._roster;\n        },\n\n        _subscribed: false,\n        isSubscribed: function(){\n            return this._subscribed;\n        },\n\n        _needSubscribe: false,\n        subscribe: function(){\n            this._needSubscribe = true;\n            if(this._integrationService.isReady()){\n                // if need subscribe and collaboration connected\n                // need send subscription\n                this._subscribe();\n            }\n        },\n\n        _subscribe: function(){\n            if(this._needSubscribe){\n                logger.info('Send subscription');\n\n                if(!this._subscribed){\n                    // if first subscribe\n                    this._bindEvents();\n                }\n\n                this._subscribed = true;\n\n                var message = {\n                    'msgdata': {\n                        'type': 'subscribe',\n                        'event': 'roster'\n                    }\n                };\n\n                this._connection.send(message);\n            }\n        },\n\n        _sort: function(){\n            this._roster.sort(function compare(a, b){\n                return a.name.localeCompare(b.name);\n            });\n        },\n\n        _find: function(item){\n            var index = -1;\n            for(var i = 0; i < this._roster.length; i++){\n                if(this._roster[i].id == item.id){\n                    index = i;\n                    break;\n                }\n            }\n            return index;\n        },\n\n        _onConnectedCollaboration: function(){\n            this._subscribe();\n        },\n\n        _onSetRoster: function(event, roster){\n            logger.info('Received roster:', roster);\n\n            var isFirst = (this._roster === null);\n\n            this._roster = roster;\n            this._sort();\n\n            if(isFirst){\n                this.trigger('ready', this);\n            }\n\n            this.trigger('reset', this._roster);\n        },\n\n        _onUpdateUser: function(event, user){\n            logger.info('Update user:', user);\n            if(user && this._roster.length > 0){\n                var index = this._find(user);\n                if(index >= 0){\n                    this._roster[index] = user;\n                    this.trigger('update', user);\n                }\n            }\n        },\n\n        _onRemoveUser: function(event, user){\n            logger.info('Removed user:', user);\n            if(user && this._roster.length > 0){\n                var index = this._find(user);\n                if(index >= 0){\n                    this._roster.splice(index, 1);\n                    this.trigger('delete', user);\n                }\n            }\n        },\n\n        _onAddUser: function(event, user){\n            logger.info('Added user:', user);\n            if(user){\n                var index = this._find(user);\n                if(index == -1){\n                    this._roster.push(user);\n                    this._sort();\n                    this.trigger('add', user);\n                }\n            }\n        }\n    }));\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Roster.js\n// module id = 5\n// module chunks = 0 1","/**\n * @class Telephony\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('IntegrationService'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Telephony');\n\n    IntegrationService.addModule('Telephony', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n            this._integrationService.on('collaboration:connected', this._onConnectedCollaboration, this);\n        },\n\n        call: function(number, callback){\n            var message = {\n                'msgdata': {\n                    'type': 'call',\n                    'number': number\n                }\n            };\n            this._connection.send(message, callback);\n        },\n\n        _bindEvents: function(){\n            logger.info('_bindEvents');\n            this._integrationService.on('setcalls', this._onSetCalls, this);\n            this._integrationService.on('updatecall', this._onUpdateCall, this);\n            this._integrationService.on('removecall', this._onRemoveCall, this);\n            this._integrationService.on('addcall', this._onAddCall, this);\n        },\n\n        _calls: null,\n\n        getCalls: function(){\n            return this._calls;\n        },\n\n        _subscribed: false,\n        isSubscribed: function(){\n            return this._subscribed;\n        },\n\n        _needSubscribe: false,\n        subscribe: function(){\n            this._needSubscribe = true;\n            if(this._integrationService.isReady()){\n                // if need subscribe and collaboration connected\n                // need send subscription\n                this._subscribe();\n            }\n        },\n\n        _subscribe: function(){\n            if(this._needSubscribe){\n                logger.info('Send subscription');\n\n                if(!this._subscribed){\n                    // if first subscribe\n                    this._bindEvents();\n                }\n\n                this._subscribed = true;\n\n                var message = {\n                    'msgdata': {\n                        'type': 'subscribe',\n                        'event': 'calls'\n                    }\n                };\n\n                this._connection.send(message);\n            }\n        },\n\n        _find: function(item){\n            var index = -1;\n            for(var i = 0; i < this._calls.length; i++){\n                if(this._calls[i].channel == item.channel){\n                    index = i;\n                    break;\n                }\n            }\n            return index;\n        },\n\n        _onConnectedCollaboration: function(){\n            this._subscribe();\n        },\n\n        _onSetCalls: function(event, calls){\n            logger.info('Received calls:', calls);\n\n            var isFirst = (this._calls === null);\n\n            this._calls = calls;\n\n            if(isFirst){\n                this.trigger('ready', this);\n            }\n\n            this.trigger('reset', this._calls);\n        },\n\n        _onUpdateCall: function(event, call){\n            logger.info('Update call:', call);\n            if(call && this._calls.length > 0){\n                var index = this._find(call);\n                if(index >= 0){\n                    this._calls[index] = call;\n                    this.trigger('update', call);\n                }\n            }\n        },\n\n        _onRemoveCall: function(event, call){\n            logger.info('Removed call:', call);\n            if(call && this._calls.length > 0){\n                var index = this._find(call);\n                if(index >= 0){\n                    this._calls.splice(index, 1);\n                    this.trigger('delete', call);\n                }\n            }\n        },\n\n        _onAddCall: function(event, call){\n            logger.info('Added call:', call);\n            if(call){\n                var index = this._find(call);\n                if(index == -1){\n                    this._calls.push(call);\n                    this.trigger('add', call);\n                }\n            }\n        }\n    }));\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Telephony.js\n// module id = 6\n// module chunks = 0 1","/**\n * @class Connector\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('ReconnectingWebSocket'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['ReconnectingWebSocket', 'EventEmitter'], factory);\n    } else if (typeof ReconnectingWebSocket !== 'undefined' && typeof ReconnectingWebSocket !== 'undefined'){\n        // Browser\n        root.Connector = factory(ReconnectingWebSocket, EventEmitter);\n    }\n}(this, function (ReconnectingWebSocket, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Connector');\n\n    function Connector(options){\n        this.initialize(options);\n    }\n\n    extend(Connector.prototype, EventEmitter, {\n\n        _options: {\n            debug: false,\n            automaticOpen: true,\n            reconnectInterval: 1000,\n            maxReconnectInterval: 5000,\n            reconnectDecay: 1,\n            timeoutInterval: 3000,\n            maxReconnectAttempts: 1\n        },\n\n        _authData: null,\n\n        _connection: null,\n        _requestsCallback: {},\n\n        _isInstalled: false,\n        _isConnected: false,\n        _isAuthorized: false,\n\n        _requestTimeout: 120000,\n        _requestTimer: null,\n\n        _currentDefaultPortIndex: 0,\n        _defaultPort: [8888, 8889, 8890],\n\n        initialize: function(options){\n            logger.info('Initialize', options);\n\n            extend(this._options, options);\n\n            var port = window.localStorage.getItem('Wildix.IntegrationService.Port');\n            if(port){\n                this.getConnection(port);\n            }else{\n                this.getConnection();\n            }\n        },\n\n        getConnection: function(port) {\n            if(!port){\n                port = this._defaultPort[this._currentDefaultPortIndex];\n            }\n            if(this._connection === null){\n                var host = 'wss://wildixintegration.eu:' + port + '/';\n                this._connection = new ReconnectingWebSocket(host, null, this._options);\n\n                this._connection.onconnecting = this._onConnectingWS.bind(this);\n                this._connection.onopen = this._onOpenWS.bind(this);\n                this._connection.onerror = this._onErrorWS.bind(this);\n                this._connection.onmessage = this._onMessageWS.bind(this);\n                this._connection.onclose = this._onCloseWS.bind(this);\n            }\n            return this._connection;\n        },\n\n        setAuthData: function(data){\n            this._authData = data;\n        },\n\n        abort: function(){\n            this._connection.onconnecting = function(event) {};\n            this._connection.onopen = function(event) {};\n            this._connection.onerror = function(event) {};\n            this._connection.onmessage = function(event) {};\n            this._connection.onclose = function(event) {};\n\n            this._connection.close();\n            this._connection = null;\n\n            this._isConnected = false;\n            this._isAuthorized = false;\n        },\n\n        isInstalled: function() {\n            return this._isInstalled;\n        },\n\n        isConnected: function() {\n            return this._isConnected;\n        },\n\n        isAuthorized: function() {\n            return this._isAuthorized;\n        },\n\n        isReady: function(){\n            if(this.isInstalled() && this.isConnected() && this.isAuthorized()){\n                return true;\n            }\n            return false;\n        },\n\n        refresh: function(){\n            this.getConnection().refresh();\n        },\n\n        open: function(){\n            this.getConnection().open();\n        },\n\n        send: function(message, callback, timeout) {\n            if(!this.isConnected()){\n                return;\n            }\n            if(!message){\n                return;\n            }\n            if(!message.hasOwnProperty('message')){\n                message = extend({}, {\n                    message: 'E_' + this._authData.app\n                }, message);\n            }\n\n            if(!message.hasOwnProperty('id')){\n                message.id = this._generateID();\n            }\n\n            if(callback){\n                if(timeout === null || typeof timeout === 'undefined' || timeout < 0){\n                    timeout = this._requestTimeout;\n                }\n                this._requestsCallback[message.id] = {\n                    callback: callback,\n                    message: message,\n                    timeoutAt: Date.now() + timeout\n                };\n\n                this._checkRequestTimeout();\n            }\n\n            var requestString = JSON.stringify(message);\n\n            return this.getConnection().send(requestString);\n        },\n\n        _getCurrentPort: function(){\n            return this._connection.url.match(/[^\\d]+(\\d+).*/)[1];\n        },\n\n        _currentCandidat: -1,\n        _connectToNextCandidat: function(){\n            this._currentCandidat++;\n\n            this._getCandidates(function(candidates){\n                if(candidates[this._currentCandidat]){\n                    this.abort();\n                    this.getConnection(candidates[this._currentCandidat]);\n                }else{\n                    this.abort();\n                    this._currentCandidat = 0;\n                    this._candidates = null;\n                }\n            }.bind(this));\n        },\n\n        _candidates: null,\n        _getCandidates: function(callback){\n            callback = callback || function(){};\n\n            if(this._candidates === null){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'candidates'\n                    }\n                };\n\n                this.send(message, function(response){\n                    if(response && response.candidates){\n                        this._candidates = response.candidates;\n                        callback(this._candidates);\n                    }\n                }.bind(this));\n            }else{\n                callback(this._candidates);\n            }\n        },\n\n        _autorize: function(){\n            if(!this.isConnected()){\n                return null;\n            }\n\n            if(!this._authData){\n                return null;\n            }\n\n            var message = {\n                'message': 'M_WISERVICE',\n                'msgdata': {\n                    'command': 'authorize',\n                    'msgdata': this._authData\n                }\n            };\n            this.send(message, function(response){\n                if(response && response.status && response.status == 'rejected'){\n                    logger.info('authorization rejected', response);\n                    this._connectToNextCandidat();\n                }else{\n                    window.localStorage.setItem('Wildix.IntegrationService.Port', this._getCurrentPort());\n                    this._isAuthorized = true;\n                    this._ready();\n                }\n            }.bind(this));\n        },\n\n        _ready: function(){\n            this.trigger('ready', this);\n        },\n\n        _checkRequestTimeout: function(){\n            if (!this._requestTimer){\n                this._requestTimer = setInterval(function(){\n                    for (var messageId in this._requestsCallback){\n                        if (this._requestsCallback.hasOwnProperty(messageId)){\n                            var request = this._requestsCallback[messageId];\n                            if (request.timeoutAt && request.timeoutAt <= Date.now()){\n                                this.trigger('requesttimeout', request);\n                                delete this._requestsCallback[messageId];\n                            }\n                        }\n                    }\n                }.bind(this), 100);\n            }\n        },\n\n        _generateID: function(len) {\n            if(!len){\n                len = 32;\n            }\n            var text = '';\n            var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n            for(var i = 0; i < len; i++) {\n                text += possible.charAt(Math.floor(Math.random() * possible.length));\n            }\n\n            return text;\n        },\n\n        _onConnectingWS: function(event) {\n            this._isConnected = false;\n            this.trigger('connecting', this);\n        },\n\n        _onOpenWS: function(event) {\n            this._isInstalled = true;\n            this._isConnected = true;\n            this.getConnection().maxReconnectAttempts = null;\n            this.trigger('connected', this);\n            this._autorize();\n        },\n\n        _onErrorWS: function(event, dd) {\n            if(this._candidates === null && this._defaultPort[this._currentDefaultPortIndex + 1]){\n                // if first connected and have next default port\n                if(this._getCurrentPort() == this._defaultPort[this._currentDefaultPortIndex]){\n                    // if port is default, then connect to the next default port\n                    this._currentDefaultPortIndex++;\n                }\n                this.abort();\n                this.getConnection();\n            }else{\n                this.abort();\n                this.trigger('error', this);\n            }\n        },\n\n        _onMessageWS: function(event) {\n            var message = null;\n            if(event.hasOwnProperty('data') && event.data){\n                try{\n                    message = JSON.parse(event.data);\n                }catch(e){\n                    logger.error('Bad message', e);\n                }\n            }\n            if(message && message.hasOwnProperty('message')){\n                switch (message.message.substr(0, 2)) {\n                    case 'E_': message.type = 'event';\n                        break;\n                    case 'R_': message.type = 'response';\n                        break;\n                    case 'C_': message.type = 'chunked';\n                        break;\n                    default: message.type = 'message';\n                        break;\n                }\n\n                message.application = message.message.substr(2);\n                message.application = message.application.toLowerCase();\n            }\n\n            if(message && message.hasOwnProperty('id')){\n                if(message.type == 'response' && this._requestsCallback.hasOwnProperty(message.id)){\n                    if(this._requestsCallback[message.id].hasOwnProperty('callback')){\n                        this._requestsCallback[message.id].callback(message.msgdata);\n                    }\n                    delete this._requestsCallback[message.id];\n                }\n            }\n\n            this.trigger(message.type + ':' + message.application, message);\n        },\n\n        _onCloseWS: function(event) {\n            if(this._isConnected){\n                this._isConnected = false;\n                logger.error('WS closed', event);\n                this.trigger('close', this);\n            }\n        }\n    });\n\n    return Connector;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Connector.js\n// module id = 7\n// module chunks = 0 1","/*\n * entry point\n */\n\nrequire('Roster');\nrequire('Chat');\nrequire('Telephony');\n\nif (typeof exports == 'object'){\n    module.exports = require('IntegrationService');\n}else{\n    require('IntegrationService');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 8\n// module chunks = 0 1","// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/reconnectingwebsocket/reconnecting-websocket.js\n// module id = 9\n// module chunks = 0 1"],"sourceRoot":""}