{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///Wildix.IntegrationService.min.js","webpack:///webpack/bootstrap 5eb2acf41dcebb729f39?2dbd","webpack:///../~/extend/index.js?4fa3","webpack:///./EventEmitter.js?5b84","webpack:///../~/js-logger/src/logger.js?779b","webpack:///./IntegrationService.js?3d10","webpack:///./Chat.js?48f1","webpack:///./Roster.js?4c1f","webpack:///./Telephony.js?ff72","webpack:///./Connector.js?0e39","webpack:///./index.js?d939","webpack:///../~/reconnectingwebsocket/reconnecting-websocket.js?7ec4"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","extend","hasOwn","toStr","toString","isArray","arr","Array","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","key","options","src","copy","copyIsArray","clone","target","arguments","length","deep","_handlers","on","event","fn","scope","push","off","filter","item","trigger","param","args","handlers","handler","apply","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","global","Logger","VERSION","logHandler","contextualLoggersByNameMap","bind","func","merge","defineLogLevel","DEBUG","INFO","TIME","WARN","ERROR","OFF","ContextualLogger","defaultContext","context","setLevel","filterLevel","log","info","newLevel","enabledFor","lvl","debug","invoke","warn","error","time","label","timeEnd","level","msgArgs","globalLogger","L","setHandler","createDefaultHandler","formatter","messages","unshift","timerStartTimeByLabelMap","invokeConsoleMethod","hdlr","Function","console","slice","timerLabel","Date","getTime","useDefaults","defaultLevel","undefined","EventEmitter","Connector","IntegrationService","initialize","logger","Modules","addModule","_options","app","version","userAgent","navigator","platform","_connectionOptions","automaticOpen","reconnectInterval","maxReconnectInterval","reconnectDelay","timeoutInterval","maxReconnectAttempts","_connection","_macComponentVersion","wiservice","_winComponentVersion","_version","toUpperCase","Module","getConnection","_onReady","_onEventWiservice","toLowerCase","_onMessage","_onConnectionError","port","setAuthData","_ready","isReady","getVersion","_countCollaborationss","data","msgdata","type","disconnected","collaboration","connected","_collaborationStatus","_countCollaborations","command","refresh","open","isConnected","getCollaborationStatus","message","send","response","force","_integrationService","IS","number","_onConnectedCollaboration","_bindEvents","_onSetRoster","_onUpdateUser","_onRemoveUser","_onAddUser","_roster","getRoster","_subscribed","isSubscribed","_needSubscribe","subscribe","_subscribe","_sort","sort","a","b","localeCompare","_find","index","id","roster","isFirst","user","splice","callback","_onSetCalls","_onUpdateCall","_onRemoveCall","_onAddCall","_calls","getCalls","channel","calls","ReconnectingWebSocket","reconnectDecay","_authData","_requestsCallback","_isInstalled","_isConnected","_isAuthorized","_requestTimeout","_requestTimer","_currentDefaultPortIndex","_defaultPort","window","localStorage","getItem","host","onconnecting","_onConnectingWS","onopen","_onOpenWS","onerror","_onErrorWS","onmessage","_onMessageWS","onclose","_onCloseWS","abort","close","isInstalled","isAuthorized","timeout","_generateID","timeoutAt","now","_checkRequestTimeout","requestString","JSON","stringify","_getCurrentPort","url","match","_currentCandidat","_connectToNextCandidat","_getCandidates","candidates","_candidates","_autorize","status","setItem","setInterval","messageId","request","len","text","possible","charAt","Math","floor","random","dd","parse","e","substr","application","__WEBPACK_AMD_DEFINE_ARRAY__","protocols","generateEvent","evt","document","createEvent","initCustomEvent","settings","reconnectAttempts","readyState","WebSocket","CONNECTING","protocol","ws","self","forcedClose","timedOut","eventTarget","createElement","addEventListener","removeEventListener","dispatchEvent","reconnectAttempt","debugAll","localWs","setTimeout","clearTimeout","OPEN","isReconnect","CLOSED","code","reason","wasClean","pow","CLOSING"],"mappings":"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","file":"Wildix.IntegrationService.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"IntegrationService\"] = factory();\n\telse\n\t\troot[\"Wildix\"] = root[\"Wildix\"] || {}, root[\"Wildix\"][\"IntegrationService\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"IntegrationService\"] = factory();\n\telse\n\t\troot[\"Wildix\"] = root[\"Wildix\"] || {}, root[\"Wildix\"][\"IntegrationService\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(extend) {\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @class EventEmitter\n */\n\n(function universalModuleDefinition(root, factory){\n    if (true){\n        // CommonJS\n        module.exports = factory();\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define([], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof ReconnectingWebSocket !== 'undefined'){\n        // Browser\n        root.EventEmitter = factory();\n    }\n}(this, function (){\n    'use strict';\n    var EventEmitter = {\n        _handlers: null,\n\n        on: function(event, fn, scope) {\n            this._handlers = this._handlers || {};\n            if(typeof this._handlers[event] === 'undefined'){\n                this._handlers[event] = [];\n            }\n\n            this._handlers[event].push({\n                fn: fn,\n                scope: scope\n            });\n        },\n\n        off: function(event, fn) {\n            if(typeof this._handlers[event] === 'undefined'){\n                return true;\n            }\n\n            this._handlers[event] = this._handlers[event].filter(\n                function(item) {\n                    if (item.fn !== fn) {\n                        return item;\n                    }\n                }\n            );\n        },\n\n        trigger: function(event, param) {\n            // console.log('trigger', event, param)\n\n            var args = arguments;\n\n            if(!this._handlers || typeof this._handlers[event] === 'undefined'){\n                return;\n            }\n\n            var handlers = this._handlers[event];\n\n            for (var i = 0; i < handlers.length; i++) {\n                var handler = handlers[i];\n                if(handler.fn){\n                    switch (args.length) {\n                        // fast cases\n                        case 1:\n                            handler.fn.call(handler.scope, event);\n                            break;\n                        case 2:\n                            handler.fn.call(handler.scope, event, param);\n                            break;\n                        case 3:\n                            handler.fn.call(handler.scope, event, param, args[2]);\n                            break;\n                            // slower\n                        default:\n                            handler.fn.apply(handler.scope, args);\n                    }\n                }\n            }\n        }\n    };\n\n    return EventEmitter;\n}));\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\r\n(function (global) {\r\n\t\"use strict\";\r\n\r\n\t// Top level module for the global, static logger instance.\r\n\tvar Logger = { };\r\n\r\n\t// For those that are at home that are keeping score.\r\n\tLogger.VERSION = \"1.3.0\";\r\n\r\n\t// Function which handles all incoming log messages.\r\n\tvar logHandler;\r\n\r\n\t// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\r\n\tvar contextualLoggersByNameMap = {};\r\n\r\n\t// Polyfill for ES5's Function.bind.\r\n\tvar bind = function(scope, func) {\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t// Super exciting object merger-matron 9000 adding another 100 bytes to your download.\r\n\tvar merge = function () {\r\n\t\tvar args = arguments, target = args[0], key, i;\r\n\t\tfor (i = 1; i < args.length; i++) {\r\n\t\t\tfor (key in args[i]) {\r\n\t\t\t\tif (!(key in target) && args[i].hasOwnProperty(key)) {\r\n\t\t\t\t\ttarget[key] = args[i][key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\t// Helper to define a logging level object; helps with optimisation.\r\n\tvar defineLogLevel = function(value, name) {\r\n\t\treturn { value: value, name: name };\r\n\t};\r\n\r\n\t// Predefined logging levels.\r\n\tLogger.DEBUG = defineLogLevel(1, 'DEBUG');\r\n\tLogger.INFO = defineLogLevel(2, 'INFO');\r\n\tLogger.TIME = defineLogLevel(3, 'TIME');\r\n\tLogger.WARN = defineLogLevel(4, 'WARN');\r\n\tLogger.ERROR = defineLogLevel(8, 'ERROR');\r\n\tLogger.OFF = defineLogLevel(99, 'OFF');\r\n\r\n\t// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\r\n\t// of each other.\r\n\tvar ContextualLogger = function(defaultContext) {\r\n\t\tthis.context = defaultContext;\r\n\t\tthis.setLevel(defaultContext.filterLevel);\r\n\t\tthis.log = this.info;  // Convenience alias.\r\n\t};\r\n\r\n\tContextualLogger.prototype = {\r\n\t\t// Changes the current logging level for the logging instance.\r\n\t\tsetLevel: function (newLevel) {\r\n\t\t\t// Ensure the supplied Level object looks valid.\r\n\t\t\tif (newLevel && \"value\" in newLevel) {\r\n\t\t\t\tthis.context.filterLevel = newLevel;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Is the logger configured to output messages at the supplied level?\r\n\t\tenabledFor: function (lvl) {\r\n\t\t\tvar filterLevel = this.context.filterLevel;\r\n\t\t\treturn lvl.value >= filterLevel.value;\r\n\t\t},\r\n\r\n\t\tdebug: function () {\r\n\t\t\tthis.invoke(Logger.DEBUG, arguments);\r\n\t\t},\r\n\r\n\t\tinfo: function () {\r\n\t\t\tthis.invoke(Logger.INFO, arguments);\r\n\t\t},\r\n\r\n\t\twarn: function () {\r\n\t\t\tthis.invoke(Logger.WARN, arguments);\r\n\t\t},\r\n\r\n\t\terror: function () {\r\n\t\t\tthis.invoke(Logger.ERROR, arguments);\r\n\t\t},\r\n\r\n\t\ttime: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'start' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttimeEnd: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'end' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Invokes the logger callback if it's not being filtered.\r\n\t\tinvoke: function (level, msgArgs) {\r\n\t\t\tif (logHandler && this.enabledFor(level)) {\r\n\t\t\t\tlogHandler(msgArgs, merge({ level: level }, this.context));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Protected instance which all calls to the to level `Logger` module will be routed through.\r\n\tvar globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });\r\n\r\n\t// Configure the global Logger instance.\r\n\t(function() {\r\n\t\t// Shortcut for optimisers.\r\n\t\tvar L = Logger;\r\n\r\n\t\tL.enabledFor = bind(globalLogger, globalLogger.enabledFor);\r\n\t\tL.debug = bind(globalLogger, globalLogger.debug);\r\n\t\tL.time = bind(globalLogger, globalLogger.time);\r\n\t\tL.timeEnd = bind(globalLogger, globalLogger.timeEnd);\r\n\t\tL.info = bind(globalLogger, globalLogger.info);\r\n\t\tL.warn = bind(globalLogger, globalLogger.warn);\r\n\t\tL.error = bind(globalLogger, globalLogger.error);\r\n\r\n\t\t// Don't forget the convenience alias!\r\n\t\tL.log = L.info;\r\n\t}());\r\n\r\n\t// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\r\n\t// object with the supplied log messages and the second being a context object which contains a hash of stateful\r\n\t// parameters which the logging function can consume.\r\n\tLogger.setHandler = function (func) {\r\n\t\tlogHandler = func;\r\n\t};\r\n\r\n\t// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\r\n\t// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\r\n\tLogger.setLevel = function(level) {\r\n\t\t// Set the globalLogger's level.\r\n\t\tglobalLogger.setLevel(level);\r\n\r\n\t\t// Apply this level to all registered contextual loggers.\r\n\t\tfor (var key in contextualLoggersByNameMap) {\r\n\t\t\tif (contextualLoggersByNameMap.hasOwnProperty(key)) {\r\n\t\t\t\tcontextualLoggersByNameMap[key].setLevel(level);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\r\n\t// default context and log handler.\r\n\tLogger.get = function (name) {\r\n\t\t// All logger instances are cached so they can be configured ahead of use.\r\n\t\treturn contextualLoggersByNameMap[name] ||\r\n\t\t\t(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));\r\n\t};\r\n\r\n\t// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\r\n\t// write to the window's console object (if present); the optional options object can be used to customise the\r\n\t// formatter used to format each log message.\r\n\tLogger.createDefaultHandler = function (options) {\r\n\t\toptions = options || {};\r\n\r\n\t\toptions.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\r\n\t\t\t// Prepend the logger's name to the log message for easy identification.\r\n\t\t\tif (context.name) {\r\n\t\t\t\tmessages.unshift(\"[\" + context.name + \"]\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\r\n\t\t// that don't offer a native console method.\r\n\t\tvar timerStartTimeByLabelMap = {};\r\n\r\n\t\t// Support for IE8+ (and other, slightly more sane environments)\r\n\t\tvar invokeConsoleMethod = function (hdlr, messages) {\r\n\t\t\tFunction.prototype.apply.call(hdlr, console, messages);\r\n\t\t};\r\n\r\n\t\t// Check for the presence of a logger.\r\n\t\tif (typeof console === \"undefined\") {\r\n\t\t\treturn function () { /* no console */ };\r\n\t\t}\r\n\r\n\t\treturn function(messages, context) {\r\n\t\t\t// Convert arguments object to Array.\r\n\t\t\tmessages = Array.prototype.slice.call(messages);\r\n\r\n\t\t\tvar hdlr = console.log;\r\n\t\t\tvar timerLabel;\r\n\r\n\t\t\tif (context.level === Logger.TIME) {\r\n\t\t\t\ttimerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\r\n\r\n\t\t\t\tif (messages[1] === 'start') {\r\n\t\t\t\t\tif (console.time) {\r\n\t\t\t\t\t\tconsole.time(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttimerStartTimeByLabelMap[timerLabel] = new Date().getTime();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (console.timeEnd) {\r\n\t\t\t\t\t\tconsole.timeEnd(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinvokeConsoleMethod(hdlr, [ timerLabel + ': ' +\r\n\t\t\t\t\t\t\t(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Delegate through to custom warn/error loggers if present on the console.\r\n\t\t\t\tif (context.level === Logger.WARN && console.warn) {\r\n\t\t\t\t\thdlr = console.warn;\r\n\t\t\t\t} else if (context.level === Logger.ERROR && console.error) {\r\n\t\t\t\t\thdlr = console.error;\r\n\t\t\t\t} else if (context.level === Logger.INFO && console.info) {\r\n\t\t\t\t\thdlr = console.info;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toptions.formatter(messages, context);\r\n\t\t\t\tinvokeConsoleMethod(hdlr, messages);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t// Configure and example a Default implementation which writes to the `window.console` (if present).  The\r\n\t// `options` hash can be used to configure the default logLevel and provide a custom message formatter.\r\n\tLogger.useDefaults = function(options) {\r\n\t\tLogger.setLevel(options && options.defaultLevel || Logger.DEBUG);\r\n\t\tLogger.setHandler(Logger.createDefaultHandler(options));\r\n\t};\r\n\r\n\t// Export to popular environments boilerplate.\r\n\tif (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (Logger),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t}\r\n\telse if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = Logger;\r\n\t}\r\n\telse {\r\n\t\tLogger._prevLogger = global.Logger;\r\n\r\n\t\tLogger.noConflict = function () {\r\n\t\t\tglobal.Logger = Logger._prevLogger;\r\n\t\t\treturn Logger;\r\n\t\t};\r\n\r\n\t\tglobal.Logger = Logger;\r\n\t}\r\n}(this));\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(extend) {/**\n * @class IntegrationService\n */\n\n(function universalModuleDefinition(root, factory){\n    if (true){\n        // CommonJS\n        module.exports = factory(__webpack_require__(2), __webpack_require__(1), __webpack_require__(7));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['Logger', 'EventEmitter', 'Connector'], factory);\n    } else if (typeof Logger !== 'undefined'){\n        // Browser\n        root.IntegrationService = factory(Logger, EventEmitter, Connector);\n    }\n}(this, function (Logger, EventEmitter, Connector){\n    'use strict';\n    // enable all logs\n    // Wildix.IntegrationService.Logger.setLevel(Wildix.IntegrationService.Logger.DEBUG)\n    // Logger.useDefaults();\n    // Logger.setLevel(Logger.WARN);  // Global logging level.\n    // Logger.setLevel(Logger.DEBUG);  // Global logging level.\n\n    var logger = Logger.get('IntegrationService');\n\n    function IntegrationService(options){\n        this.initialize(options);\n    }\n\n    IntegrationService.Logger = Logger;\n\n    IntegrationService.Modules = {};\n\n    IntegrationService.addModule = function(name, module){\n        IntegrationService.Modules[name] = module;\n    };\n\n    extend(IntegrationService.prototype, EventEmitter, {\n        _options: {\n            app: 'APP_WEBCRM',\n            name: 'WebCRM',\n            version: '0.0.1',\n            userAgent: navigator.userAgent,\n            platform: navigator.platform\n        },\n\n        _connectionOptions: {\n            debug: false,\n            automaticOpen: true,\n            reconnectInterval: 1000,\n            maxReconnectInterval: 5000,\n            reconnectDelay: 1,\n            timeoutInterval: 3000,\n            maxReconnectAttempts: 1\n        },\n\n        _connection: null,\n\n        _macComponentVersion: {\n            'wiservice': '2.5.0'\n        },\n\n        _winComponentVersion: {\n            'wiservice': '2.5.0'\n        },\n\n        _version: null,\n\n        initialize: function(options){\n            logger.info('Initialize Integration service', options);\n\n            extend(this._options, options);\n\n            this._options.app = 'APP_' + this._options.name.toUpperCase();\n\n            for (var key in IntegrationService.Modules) {\n                logger.info('Build module:', key);\n                if(typeof IntegrationService.Modules[key] === 'object'){\n                    var Module = function(){};\n                    Module.prototype = IntegrationService.Modules[key];\n\n                    this[key] = new Module();\n                    this[key].initialize(this);\n                }else{\n                    this[key] = new IntegrationService.Modules[key](this);\n                }\n            }\n\n            this.getConnection().on('ready', this._onReady, this);\n            this.getConnection().on('event:wiservice', this._onEventWiservice, this);\n            this.getConnection().on('message:' + this._options.app.toLowerCase(), this._onMessage, this);\n            this.getConnection().on('error', this._onConnectionError, this);\n        },\n\n        getConnection: function(port) {\n            if(this._connection === null){\n                this._connection = new Connector(this._connectionOptions);\n                this._connection.setAuthData(this._options);\n            }\n            return this._connection;\n        },\n\n        _ready: false,\n        isReady: function(){\n            return this._ready;\n        },\n\n        _onReady: function(){\n            this.getVersion();\n        },\n\n        _countCollaborationss: 0,\n        _onEventWiservice: function(event, data){\n            logger.info('_onEventWiservice', event, data);\n            if(data && data.msgdata){\n                if(data.msgdata.type == 'connectionstatus'){\n                    if(data.msgdata.disconnected && data.msgdata.disconnected.collaboration){\n                        // maybe disconnected\n                        if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                            // have another collaboration connection\n                        }else{\n                            this._collaborationStatus = 'disconnected';\n                            this.trigger('collaboration:' + this._collaborationStatus, this);\n                        }\n                    }else if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                        if(this._countCollaborations != data.msgdata.connected.collaboration.length){\n                            this._collaborationStatus = 'connected';\n                            this.trigger('collaboration:' + this._collaborationStatus, this);\n                        }\n                    }\n\n                    this._countCollaborations = 0;\n                    if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                        this._countCollaborations = data.msgdata.connected.collaboration.length;\n                    }\n                }\n            }\n        },\n\n        _onMessage: function(event, data){\n            this.trigger(data.msgdata.command, data.msgdata.msgdata);\n        },\n\n        _onConnectionError: function(){\n            this.trigger('connection:error', this);\n        },\n\n        refresh: function(){\n            this.getConnection().refresh();\n        },\n\n        open: function(){\n            this.getConnection().open();\n        },\n\n        isConnected: function(){\n            return this.getConnection().isConnected();\n        },\n\n        _collaborationStatus: null,\n        getCollaborationStatus: function(){\n            if(!this.isConnected()){\n                return null;\n            }\n            if(this._collaborationStatus === null){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'getconnectionstatus'\n                    }\n                };\n                this.getConnection().send(message, function(response){\n                    logger.info('collaboration status', response);\n                    var connected = response.connected || {};\n                    if(connected.collaboration && connected.collaboration.length > 0){\n                        this._collaborationStatus = 'connected';\n                        this._countCollaborations = response.connected.collaboration.length;\n                        this._ready = true;\n                        this.trigger('ready', this);\n                        this.trigger('collaboration:' + this._collaborationStatus, this);\n                    }\n                }.bind(this));\n            }\n            return this._collaborationStatus;\n        },\n\n        getVersion: function(name, force){\n            if(!this.isConnected()){\n                return null;\n            }\n\n            if(this._version === null || force){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'getversion'\n                    }\n                };\n                this.getConnection().send(message, function(response){\n                    if(response && response.wiservice){\n                        this._version = response;\n                        this.getCollaborationStatus();\n                    }\n                }.bind(this));\n            }\n\n            if(name){\n                if(this._version && this._version.hasOwnProperty(name) && this._version[name]){\n                    return this._version[name];\n                }\n                return null;\n            }\n            return this._version;\n        }\n    });\n\n    return IntegrationService;\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Logger, extend) {/**\n * @class Chat\n */\n\n(function universalModuleDefinition(root, factory){\n    if (true){\n        // CommonJS\n        module.exports = factory(__webpack_require__(3), __webpack_require__(1));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Chat');\n\n    IntegrationService.addModule('Chat', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n        },\n\n        open: function(number){\n            var message = {\n                'msgdata': {\n                    'type': 'chat',\n                    'number': number\n                }\n            };\n            this._connection.send(message);\n        }\n\n    }));\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(0)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Logger, extend) {/**\n * @class Roster\n */\n\n(function universalModuleDefinition(root, factory){\n    if (true){\n        // CommonJS\n        module.exports = factory(__webpack_require__(3), __webpack_require__(1));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Roster');\n\n    IntegrationService.addModule('Roster', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n            this._integrationService.on('collaboration:connected', this._onConnectedCollaboration, this);\n        },\n\n        _bindEvents: function(){\n            logger.info('_bindEvents');\n            this._integrationService.on('setroster', this._onSetRoster, this);\n            this._integrationService.on('updateuser', this._onUpdateUser, this);\n            this._integrationService.on('removeuser', this._onRemoveUser, this);\n            this._integrationService.on('adduser', this._onAddUser, this);\n        },\n\n        _roster: null,\n\n        getRoster: function(){\n            return this._roster;\n        },\n\n        _subscribed: false,\n        isSubscribed: function(){\n            return this._subscribed;\n        },\n\n        _needSubscribe: false,\n        subscribe: function(){\n            this._needSubscribe = true;\n            if(this._integrationService.isReady()){\n                // if need subscribe and collaboration connected\n                // need send subscription\n                this._subscribe();\n            }\n        },\n\n        _subscribe: function(){\n            if(this._needSubscribe){\n                logger.info('Send subscription');\n\n                if(!this._subscribed){\n                    // if first subscribe\n                    this._bindEvents();\n                }\n\n                this._subscribed = true;\n\n                var message = {\n                    'msgdata': {\n                        'type': 'subscribe',\n                        'event': 'roster'\n                    }\n                };\n\n                this._connection.send(message);\n            }\n        },\n\n        _sort: function(){\n            this._roster.sort(function compare(a, b){\n                return a.name.localeCompare(b.name);\n            });\n        },\n\n        _find: function(item){\n            var index = -1;\n            for(var i = 0; i < this._roster.length; i++){\n                if(this._roster[i].id == item.id){\n                    index = i;\n                    break;\n                }\n            }\n            return index;\n        },\n\n        _onConnectedCollaboration: function(){\n            this._subscribe();\n        },\n\n        _onSetRoster: function(event, roster){\n            logger.info('Received roster:', roster);\n\n            var isFirst = (this._roster === null);\n\n            this._roster = roster;\n            this._sort();\n\n            if(isFirst){\n                this.trigger('ready', this);\n            }\n\n            this.trigger('reset', this._roster);\n        },\n\n        _onUpdateUser: function(event, user){\n            logger.info('Update user:', user);\n            if(user && this._roster.length > 0){\n                var index = this._find(user);\n                if(index >= 0){\n                    this._roster[index] = user;\n                    this.trigger('update', user);\n                }\n            }\n        },\n\n        _onRemoveUser: function(event, user){\n            logger.info('Removed user:', user);\n            if(user && this._roster.length > 0){\n                var index = this._find(user);\n                if(index >= 0){\n                    this._roster.splice(index, 1);\n                    this.trigger('delete', user);\n                }\n            }\n        },\n\n        _onAddUser: function(event, user){\n            logger.info('Added user:', user);\n            if(user){\n                var index = this._find(user);\n                if(index == -1){\n                    this._roster.push(user);\n                    this._sort();\n                    this.trigger('add', user);\n                }\n            }\n        }\n    }));\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(0)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Logger, extend) {/**\n * @class Telephony\n */\n\n(function universalModuleDefinition(root, factory){\n    if (true){\n        // CommonJS\n        module.exports = factory(__webpack_require__(3), __webpack_require__(1));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Telephony');\n\n    IntegrationService.addModule('Telephony', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n            this._integrationService.on('collaboration:connected', this._onConnectedCollaboration, this);\n        },\n\n        call: function(number, callback){\n            var message = {\n                'msgdata': {\n                    'type': 'call',\n                    'number': number\n                }\n            };\n            this._connection.send(message, callback);\n        },\n\n        _bindEvents: function(){\n            logger.info('_bindEvents');\n            this._integrationService.on('setcalls', this._onSetCalls, this);\n            this._integrationService.on('updatecall', this._onUpdateCall, this);\n            this._integrationService.on('removecall', this._onRemoveCall, this);\n            this._integrationService.on('addcall', this._onAddCall, this);\n        },\n\n        _calls: null,\n\n        getCalls: function(){\n            return this._calls;\n        },\n\n        _subscribed: false,\n        isSubscribed: function(){\n            return this._subscribed;\n        },\n\n        _needSubscribe: false,\n        subscribe: function(){\n            this._needSubscribe = true;\n            if(this._integrationService.isReady()){\n                // if need subscribe and collaboration connected\n                // need send subscription\n                this._subscribe();\n            }\n        },\n\n        _subscribe: function(){\n            if(this._needSubscribe){\n                logger.info('Send subscription');\n\n                if(!this._subscribed){\n                    // if first subscribe\n                    this._bindEvents();\n                }\n\n                this._subscribed = true;\n\n                var message = {\n                    'msgdata': {\n                        'type': 'subscribe',\n                        'event': 'calls'\n                    }\n                };\n\n                this._connection.send(message);\n            }\n        },\n\n        _find: function(item){\n            var index = -1;\n            for(var i = 0; i < this._calls.length; i++){\n                if(this._calls[i].channel == item.channel){\n                    index = i;\n                    break;\n                }\n            }\n            return index;\n        },\n\n        _onConnectedCollaboration: function(){\n            this._subscribe();\n        },\n\n        _onSetCalls: function(event, calls){\n            logger.info('Received calls:', calls);\n\n            var isFirst = (this._calls === null);\n\n            this._calls = calls;\n\n            if(isFirst){\n                this.trigger('ready', this);\n            }\n\n            this.trigger('reset', this._calls);\n        },\n\n        _onUpdateCall: function(event, call){\n            logger.info('Update call:', call);\n            if(call && this._calls.length > 0){\n                var index = this._find(call);\n                if(index >= 0){\n                    this._calls[index] = call;\n                    this.trigger('update', call);\n                }\n            }\n        },\n\n        _onRemoveCall: function(event, call){\n            logger.info('Removed call:', call);\n            if(call && this._calls.length > 0){\n                var index = this._find(call);\n                if(index >= 0){\n                    this._calls.splice(index, 1);\n                    this.trigger('delete', call);\n                }\n            }\n        },\n\n        _onAddCall: function(event, call){\n            logger.info('Added call:', call);\n            if(call){\n                var index = this._find(call);\n                if(index == -1){\n                    this._calls.push(call);\n                    this.trigger('add', call);\n                }\n            }\n        }\n    }));\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(0)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Logger, extend) {/**\n * @class Connector\n */\n\n(function universalModuleDefinition(root, factory){\n    if (true){\n        // CommonJS\n        module.exports = factory(__webpack_require__(9), __webpack_require__(1));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['ReconnectingWebSocket', 'EventEmitter'], factory);\n    } else if (typeof ReconnectingWebSocket !== 'undefined' && typeof ReconnectingWebSocket !== 'undefined'){\n        // Browser\n        root.Connector = factory(ReconnectingWebSocket, EventEmitter);\n    }\n}(this, function (ReconnectingWebSocket, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Connector');\n\n    function Connector(options){\n        this.initialize(options);\n    }\n\n    extend(Connector.prototype, EventEmitter, {\n\n        _options: {\n            debug: false,\n            automaticOpen: true,\n            reconnectInterval: 1000,\n            maxReconnectInterval: 5000,\n            reconnectDecay: 1,\n            timeoutInterval: 3000,\n            maxReconnectAttempts: 1\n        },\n\n        _authData: null,\n\n        _connection: null,\n        _requestsCallback: {},\n\n        _isInstalled: false,\n        _isConnected: false,\n        _isAuthorized: false,\n\n        _requestTimeout: 120000,\n        _requestTimer: null,\n\n        _currentDefaultPortIndex: 0,\n        _defaultPort: [8888, 8889, 8890],\n\n        initialize: function(options){\n            logger.info('Initialize', options);\n\n            extend(this._options, options);\n\n            var port = window.localStorage.getItem('Wildix.IntegrationService.Port');\n            if(port){\n                this.getConnection(port);\n            }else{\n                this.getConnection();\n            }\n        },\n\n        getConnection: function(port) {\n            if(!port){\n                port = this._defaultPort[this._currentDefaultPortIndex];\n            }\n            if(this._connection === null){\n                var host = 'wss://wildixintegration.eu:' + port + '/';\n                this._connection = new ReconnectingWebSocket(host, null, this._options);\n\n                this._connection.onconnecting = this._onConnectingWS.bind(this);\n                this._connection.onopen = this._onOpenWS.bind(this);\n                this._connection.onerror = this._onErrorWS.bind(this);\n                this._connection.onmessage = this._onMessageWS.bind(this);\n                this._connection.onclose = this._onCloseWS.bind(this);\n            }\n            return this._connection;\n        },\n\n        setAuthData: function(data){\n            this._authData = data;\n        },\n\n        abort: function(){\n            this._connection.onconnecting = function(event) {};\n            this._connection.onopen = function(event) {};\n            this._connection.onerror = function(event) {};\n            this._connection.onmessage = function(event) {};\n            this._connection.onclose = function(event) {};\n\n            this._connection.close();\n            this._connection = null;\n\n            this._isConnected = false;\n            this._isAuthorized = false;\n        },\n\n        isInstalled: function() {\n            return this._isInstalled;\n        },\n\n        isConnected: function() {\n            return this._isConnected;\n        },\n\n        isAuthorized: function() {\n            return this._isAuthorized;\n        },\n\n        isReady: function(){\n            if(this.isInstalled() && this.isConnected() && this.isAuthorized()){\n                return true;\n            }\n            return false;\n        },\n\n        refresh: function(){\n            this.getConnection().refresh();\n        },\n\n        open: function(){\n            this.getConnection().open();\n        },\n\n        send: function(message, callback, timeout) {\n            if(!this.isConnected()){\n                return;\n            }\n            if(!message){\n                return;\n            }\n            if(!message.hasOwnProperty('message')){\n                message = extend({}, {\n                    message: 'E_' + this._authData.app\n                }, message);\n            }\n\n            if(!message.hasOwnProperty('id')){\n                message.id = this._generateID();\n            }\n\n            if(callback){\n                if(timeout === null || typeof timeout === 'undefined' || timeout < 0){\n                    timeout = this._requestTimeout;\n                }\n                this._requestsCallback[message.id] = {\n                    callback: callback,\n                    message: message,\n                    timeoutAt: Date.now() + timeout\n                };\n\n                this._checkRequestTimeout();\n            }\n\n            var requestString = JSON.stringify(message);\n\n            return this.getConnection().send(requestString);\n        },\n\n        _getCurrentPort: function(){\n            return this._connection.url.match(/[^\\d]+(\\d+).*/)[1];\n        },\n\n        _currentCandidat: -1,\n        _connectToNextCandidat: function(){\n            this._currentCandidat++;\n\n            this._getCandidates(function(candidates){\n                if(candidates[this._currentCandidat]){\n                    this.abort();\n                    this.getConnection(candidates[this._currentCandidat]);\n                }else{\n                    this.abort();\n                    this._currentCandidat = 0;\n                    this._candidates = null;\n                }\n            }.bind(this));\n        },\n\n        _candidates: null,\n        _getCandidates: function(callback){\n            callback = callback || function(){};\n\n            if(this._candidates === null){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'candidates'\n                    }\n                };\n\n                this.send(message, function(response){\n                    if(response && response.candidates){\n                        this._candidates = response.candidates;\n                        callback(this._candidates);\n                    }\n                }.bind(this));\n            }else{\n                callback(this._candidates);\n            }\n        },\n\n        _autorize: function(){\n            if(!this.isConnected()){\n                return null;\n            }\n\n            if(!this._authData){\n                return null;\n            }\n\n            var message = {\n                'message': 'M_WISERVICE',\n                'msgdata': {\n                    'command': 'authorize',\n                    'msgdata': this._authData\n                }\n            };\n            this.send(message, function(response){\n                if(response && response.status && response.status == 'rejected'){\n                    logger.info('authorization rejected', response);\n                    this._connectToNextCandidat();\n                }else{\n                    window.localStorage.setItem('Wildix.IntegrationService.Port', this._getCurrentPort());\n                    this._isAuthorized = true;\n                    this._ready();\n                }\n            }.bind(this));\n        },\n\n        _ready: function(){\n            this.trigger('ready', this);\n        },\n\n        _checkRequestTimeout: function(){\n            if (!this._requestTimer){\n                this._requestTimer = setInterval(function(){\n                    for (var messageId in this._requestsCallback){\n                        if (this._requestsCallback.hasOwnProperty(messageId)){\n                            var request = this._requestsCallback[messageId];\n                            if (request.timeoutAt && request.timeoutAt <= Date.now()){\n                                this.trigger('requesttimeout', request);\n                                delete this._requestsCallback[messageId];\n                            }\n                        }\n                    }\n                }.bind(this), 100);\n            }\n        },\n\n        _generateID: function(len) {\n            if(!len){\n                len = 32;\n            }\n            var text = '';\n            var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n            for(var i = 0; i < len; i++) {\n                text += possible.charAt(Math.floor(Math.random() * possible.length));\n            }\n\n            return text;\n        },\n\n        _onConnectingWS: function(event) {\n            this._isConnected = false;\n            this.trigger('connecting', this);\n        },\n\n        _onOpenWS: function(event) {\n            this._isInstalled = true;\n            this._isConnected = true;\n            this.getConnection().maxReconnectAttempts = null;\n            this.trigger('connected', this);\n            this._autorize();\n        },\n\n        _onErrorWS: function(event, dd) {\n            if(this._candidates === null && this._defaultPort[this._currentDefaultPortIndex + 1]){\n                // if first connected and have next default port\n                if(this._getCurrentPort() == this._defaultPort[this._currentDefaultPortIndex]){\n                    // if port is default, then connect to the next default port\n                    this._currentDefaultPortIndex++;\n                }\n                this.abort();\n                this.getConnection();\n            }else{\n                this.abort();\n                this.trigger('error', this);\n            }\n        },\n\n        _onMessageWS: function(event) {\n            var message = null;\n            if(event.hasOwnProperty('data') && event.data){\n                try{\n                    message = JSON.parse(event.data);\n                }catch(e){\n                    logger.error('Bad message', e);\n                }\n            }\n            if(message && message.hasOwnProperty('message')){\n                switch (message.message.substr(0, 2)) {\n                    case 'E_': message.type = 'event';\n                        break;\n                    case 'R_': message.type = 'response';\n                        break;\n                    case 'C_': message.type = 'chunked';\n                        break;\n                    default: message.type = 'message';\n                        break;\n                }\n\n                message.application = message.message.substr(2);\n                message.application = message.application.toLowerCase();\n            }\n\n            if(message && message.hasOwnProperty('id')){\n                if(message.type == 'response' && this._requestsCallback.hasOwnProperty(message.id)){\n                    if(this._requestsCallback[message.id].hasOwnProperty('callback')){\n                        this._requestsCallback[message.id].callback(message.msgdata);\n                    }\n                    delete this._requestsCallback[message.id];\n                }\n            }\n\n            this.trigger(message.type + ':' + message.application, message);\n        },\n\n        _onCloseWS: function(event) {\n            if(this._isConnected){\n                this._isConnected = false;\n                logger.error('WS closed', event);\n                this.trigger('close', this);\n            }\n        }\n    });\n\n    return Connector;\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(0)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n * entry point\n */\n\n__webpack_require__(5);\n__webpack_require__(4);\n__webpack_require__(6);\n\nif (true){\n    module.exports = __webpack_require__(3);\n}else{\n    require('IntegrationService');\n}\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Wildix.IntegrationService.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5eb2acf41dcebb729f39","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/extend/index.js\n// module id = 0\n// module chunks = 0 1","/**\n * @class EventEmitter\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory();\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define([], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof ReconnectingWebSocket !== 'undefined'){\n        // Browser\n        root.EventEmitter = factory();\n    }\n}(this, function (){\n    'use strict';\n    var EventEmitter = {\n        _handlers: null,\n\n        on: function(event, fn, scope) {\n            this._handlers = this._handlers || {};\n            if(typeof this._handlers[event] === 'undefined'){\n                this._handlers[event] = [];\n            }\n\n            this._handlers[event].push({\n                fn: fn,\n                scope: scope\n            });\n        },\n\n        off: function(event, fn) {\n            if(typeof this._handlers[event] === 'undefined'){\n                return true;\n            }\n\n            this._handlers[event] = this._handlers[event].filter(\n                function(item) {\n                    if (item.fn !== fn) {\n                        return item;\n                    }\n                }\n            );\n        },\n\n        trigger: function(event, param) {\n            // console.log('trigger', event, param)\n\n            var args = arguments;\n\n            if(!this._handlers || typeof this._handlers[event] === 'undefined'){\n                return;\n            }\n\n            var handlers = this._handlers[event];\n\n            for (var i = 0; i < handlers.length; i++) {\n                var handler = handlers[i];\n                if(handler.fn){\n                    switch (args.length) {\n                        // fast cases\n                        case 1:\n                            handler.fn.call(handler.scope, event);\n                            break;\n                        case 2:\n                            handler.fn.call(handler.scope, event, param);\n                            break;\n                        case 3:\n                            handler.fn.call(handler.scope, event, param, args[2]);\n                            break;\n                            // slower\n                        default:\n                            handler.fn.apply(handler.scope, args);\n                    }\n                }\n            }\n        }\n    };\n\n    return EventEmitter;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./EventEmitter.js\n// module id = 1\n// module chunks = 0 1","/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\r\n(function (global) {\r\n\t\"use strict\";\r\n\r\n\t// Top level module for the global, static logger instance.\r\n\tvar Logger = { };\r\n\r\n\t// For those that are at home that are keeping score.\r\n\tLogger.VERSION = \"1.3.0\";\r\n\r\n\t// Function which handles all incoming log messages.\r\n\tvar logHandler;\r\n\r\n\t// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\r\n\tvar contextualLoggersByNameMap = {};\r\n\r\n\t// Polyfill for ES5's Function.bind.\r\n\tvar bind = function(scope, func) {\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t// Super exciting object merger-matron 9000 adding another 100 bytes to your download.\r\n\tvar merge = function () {\r\n\t\tvar args = arguments, target = args[0], key, i;\r\n\t\tfor (i = 1; i < args.length; i++) {\r\n\t\t\tfor (key in args[i]) {\r\n\t\t\t\tif (!(key in target) && args[i].hasOwnProperty(key)) {\r\n\t\t\t\t\ttarget[key] = args[i][key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\t// Helper to define a logging level object; helps with optimisation.\r\n\tvar defineLogLevel = function(value, name) {\r\n\t\treturn { value: value, name: name };\r\n\t};\r\n\r\n\t// Predefined logging levels.\r\n\tLogger.DEBUG = defineLogLevel(1, 'DEBUG');\r\n\tLogger.INFO = defineLogLevel(2, 'INFO');\r\n\tLogger.TIME = defineLogLevel(3, 'TIME');\r\n\tLogger.WARN = defineLogLevel(4, 'WARN');\r\n\tLogger.ERROR = defineLogLevel(8, 'ERROR');\r\n\tLogger.OFF = defineLogLevel(99, 'OFF');\r\n\r\n\t// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\r\n\t// of each other.\r\n\tvar ContextualLogger = function(defaultContext) {\r\n\t\tthis.context = defaultContext;\r\n\t\tthis.setLevel(defaultContext.filterLevel);\r\n\t\tthis.log = this.info;  // Convenience alias.\r\n\t};\r\n\r\n\tContextualLogger.prototype = {\r\n\t\t// Changes the current logging level for the logging instance.\r\n\t\tsetLevel: function (newLevel) {\r\n\t\t\t// Ensure the supplied Level object looks valid.\r\n\t\t\tif (newLevel && \"value\" in newLevel) {\r\n\t\t\t\tthis.context.filterLevel = newLevel;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Is the logger configured to output messages at the supplied level?\r\n\t\tenabledFor: function (lvl) {\r\n\t\t\tvar filterLevel = this.context.filterLevel;\r\n\t\t\treturn lvl.value >= filterLevel.value;\r\n\t\t},\r\n\r\n\t\tdebug: function () {\r\n\t\t\tthis.invoke(Logger.DEBUG, arguments);\r\n\t\t},\r\n\r\n\t\tinfo: function () {\r\n\t\t\tthis.invoke(Logger.INFO, arguments);\r\n\t\t},\r\n\r\n\t\twarn: function () {\r\n\t\t\tthis.invoke(Logger.WARN, arguments);\r\n\t\t},\r\n\r\n\t\terror: function () {\r\n\t\t\tthis.invoke(Logger.ERROR, arguments);\r\n\t\t},\r\n\r\n\t\ttime: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'start' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttimeEnd: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'end' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Invokes the logger callback if it's not being filtered.\r\n\t\tinvoke: function (level, msgArgs) {\r\n\t\t\tif (logHandler && this.enabledFor(level)) {\r\n\t\t\t\tlogHandler(msgArgs, merge({ level: level }, this.context));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Protected instance which all calls to the to level `Logger` module will be routed through.\r\n\tvar globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });\r\n\r\n\t// Configure the global Logger instance.\r\n\t(function() {\r\n\t\t// Shortcut for optimisers.\r\n\t\tvar L = Logger;\r\n\r\n\t\tL.enabledFor = bind(globalLogger, globalLogger.enabledFor);\r\n\t\tL.debug = bind(globalLogger, globalLogger.debug);\r\n\t\tL.time = bind(globalLogger, globalLogger.time);\r\n\t\tL.timeEnd = bind(globalLogger, globalLogger.timeEnd);\r\n\t\tL.info = bind(globalLogger, globalLogger.info);\r\n\t\tL.warn = bind(globalLogger, globalLogger.warn);\r\n\t\tL.error = bind(globalLogger, globalLogger.error);\r\n\r\n\t\t// Don't forget the convenience alias!\r\n\t\tL.log = L.info;\r\n\t}());\r\n\r\n\t// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\r\n\t// object with the supplied log messages and the second being a context object which contains a hash of stateful\r\n\t// parameters which the logging function can consume.\r\n\tLogger.setHandler = function (func) {\r\n\t\tlogHandler = func;\r\n\t};\r\n\r\n\t// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\r\n\t// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\r\n\tLogger.setLevel = function(level) {\r\n\t\t// Set the globalLogger's level.\r\n\t\tglobalLogger.setLevel(level);\r\n\r\n\t\t// Apply this level to all registered contextual loggers.\r\n\t\tfor (var key in contextualLoggersByNameMap) {\r\n\t\t\tif (contextualLoggersByNameMap.hasOwnProperty(key)) {\r\n\t\t\t\tcontextualLoggersByNameMap[key].setLevel(level);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\r\n\t// default context and log handler.\r\n\tLogger.get = function (name) {\r\n\t\t// All logger instances are cached so they can be configured ahead of use.\r\n\t\treturn contextualLoggersByNameMap[name] ||\r\n\t\t\t(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));\r\n\t};\r\n\r\n\t// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\r\n\t// write to the window's console object (if present); the optional options object can be used to customise the\r\n\t// formatter used to format each log message.\r\n\tLogger.createDefaultHandler = function (options) {\r\n\t\toptions = options || {};\r\n\r\n\t\toptions.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\r\n\t\t\t// Prepend the logger's name to the log message for easy identification.\r\n\t\t\tif (context.name) {\r\n\t\t\t\tmessages.unshift(\"[\" + context.name + \"]\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\r\n\t\t// that don't offer a native console method.\r\n\t\tvar timerStartTimeByLabelMap = {};\r\n\r\n\t\t// Support for IE8+ (and other, slightly more sane environments)\r\n\t\tvar invokeConsoleMethod = function (hdlr, messages) {\r\n\t\t\tFunction.prototype.apply.call(hdlr, console, messages);\r\n\t\t};\r\n\r\n\t\t// Check for the presence of a logger.\r\n\t\tif (typeof console === \"undefined\") {\r\n\t\t\treturn function () { /* no console */ };\r\n\t\t}\r\n\r\n\t\treturn function(messages, context) {\r\n\t\t\t// Convert arguments object to Array.\r\n\t\t\tmessages = Array.prototype.slice.call(messages);\r\n\r\n\t\t\tvar hdlr = console.log;\r\n\t\t\tvar timerLabel;\r\n\r\n\t\t\tif (context.level === Logger.TIME) {\r\n\t\t\t\ttimerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\r\n\r\n\t\t\t\tif (messages[1] === 'start') {\r\n\t\t\t\t\tif (console.time) {\r\n\t\t\t\t\t\tconsole.time(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttimerStartTimeByLabelMap[timerLabel] = new Date().getTime();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (console.timeEnd) {\r\n\t\t\t\t\t\tconsole.timeEnd(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinvokeConsoleMethod(hdlr, [ timerLabel + ': ' +\r\n\t\t\t\t\t\t\t(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Delegate through to custom warn/error loggers if present on the console.\r\n\t\t\t\tif (context.level === Logger.WARN && console.warn) {\r\n\t\t\t\t\thdlr = console.warn;\r\n\t\t\t\t} else if (context.level === Logger.ERROR && console.error) {\r\n\t\t\t\t\thdlr = console.error;\r\n\t\t\t\t} else if (context.level === Logger.INFO && console.info) {\r\n\t\t\t\t\thdlr = console.info;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toptions.formatter(messages, context);\r\n\t\t\t\tinvokeConsoleMethod(hdlr, messages);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t// Configure and example a Default implementation which writes to the `window.console` (if present).  The\r\n\t// `options` hash can be used to configure the default logLevel and provide a custom message formatter.\r\n\tLogger.useDefaults = function(options) {\r\n\t\tLogger.setLevel(options && options.defaultLevel || Logger.DEBUG);\r\n\t\tLogger.setHandler(Logger.createDefaultHandler(options));\r\n\t};\r\n\r\n\t// Export to popular environments boilerplate.\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine(Logger);\r\n\t}\r\n\telse if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = Logger;\r\n\t}\r\n\telse {\r\n\t\tLogger._prevLogger = global.Logger;\r\n\r\n\t\tLogger.noConflict = function () {\r\n\t\t\tglobal.Logger = Logger._prevLogger;\r\n\t\t\treturn Logger;\r\n\t\t};\r\n\r\n\t\tglobal.Logger = Logger;\r\n\t}\r\n}(this));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/js-logger/src/logger.js\n// module id = 2\n// module chunks = 0 1","/**\n * @class IntegrationService\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('Logger'), require('EventEmitter'), require('Connector'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['Logger', 'EventEmitter', 'Connector'], factory);\n    } else if (typeof Logger !== 'undefined'){\n        // Browser\n        root.IntegrationService = factory(Logger, EventEmitter, Connector);\n    }\n}(this, function (Logger, EventEmitter, Connector){\n    'use strict';\n    // enable all logs\n    // Wildix.IntegrationService.Logger.setLevel(Wildix.IntegrationService.Logger.DEBUG)\n    // Logger.useDefaults();\n    // Logger.setLevel(Logger.WARN);  // Global logging level.\n    // Logger.setLevel(Logger.DEBUG);  // Global logging level.\n\n    var logger = Logger.get('IntegrationService');\n\n    function IntegrationService(options){\n        this.initialize(options);\n    }\n\n    IntegrationService.Logger = Logger;\n\n    IntegrationService.Modules = {};\n\n    IntegrationService.addModule = function(name, module){\n        IntegrationService.Modules[name] = module;\n    };\n\n    extend(IntegrationService.prototype, EventEmitter, {\n        _options: {\n            app: 'APP_WEBCRM',\n            name: 'WebCRM',\n            version: '0.0.1',\n            userAgent: navigator.userAgent,\n            platform: navigator.platform\n        },\n\n        _connectionOptions: {\n            debug: false,\n            automaticOpen: true,\n            reconnectInterval: 1000,\n            maxReconnectInterval: 5000,\n            reconnectDelay: 1,\n            timeoutInterval: 3000,\n            maxReconnectAttempts: 1\n        },\n\n        _connection: null,\n\n        _macComponentVersion: {\n            'wiservice': '2.5.0'\n        },\n\n        _winComponentVersion: {\n            'wiservice': '2.5.0'\n        },\n\n        _version: null,\n\n        initialize: function(options){\n            logger.info('Initialize Integration service', options);\n\n            extend(this._options, options);\n\n            this._options.app = 'APP_' + this._options.name.toUpperCase();\n\n            for (var key in IntegrationService.Modules) {\n                logger.info('Build module:', key);\n                if(typeof IntegrationService.Modules[key] === 'object'){\n                    var Module = function(){};\n                    Module.prototype = IntegrationService.Modules[key];\n\n                    this[key] = new Module();\n                    this[key].initialize(this);\n                }else{\n                    this[key] = new IntegrationService.Modules[key](this);\n                }\n            }\n\n            this.getConnection().on('ready', this._onReady, this);\n            this.getConnection().on('event:wiservice', this._onEventWiservice, this);\n            this.getConnection().on('message:' + this._options.app.toLowerCase(), this._onMessage, this);\n            this.getConnection().on('error', this._onConnectionError, this);\n        },\n\n        getConnection: function(port) {\n            if(this._connection === null){\n                this._connection = new Connector(this._connectionOptions);\n                this._connection.setAuthData(this._options);\n            }\n            return this._connection;\n        },\n\n        _ready: false,\n        isReady: function(){\n            return this._ready;\n        },\n\n        _onReady: function(){\n            this.getVersion();\n        },\n\n        _countCollaborationss: 0,\n        _onEventWiservice: function(event, data){\n            logger.info('_onEventWiservice', event, data);\n            if(data && data.msgdata){\n                if(data.msgdata.type == 'connectionstatus'){\n                    if(data.msgdata.disconnected && data.msgdata.disconnected.collaboration){\n                        // maybe disconnected\n                        if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                            // have another collaboration connection\n                        }else{\n                            this._collaborationStatus = 'disconnected';\n                            this.trigger('collaboration:' + this._collaborationStatus, this);\n                        }\n                    }else if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                        if(this._countCollaborations != data.msgdata.connected.collaboration.length){\n                            this._collaborationStatus = 'connected';\n                            this.trigger('collaboration:' + this._collaborationStatus, this);\n                        }\n                    }\n\n                    this._countCollaborations = 0;\n                    if(data.msgdata.connected && data.msgdata.connected.collaboration){\n                        this._countCollaborations = data.msgdata.connected.collaboration.length;\n                    }\n                }\n            }\n        },\n\n        _onMessage: function(event, data){\n            this.trigger(data.msgdata.command, data.msgdata.msgdata);\n        },\n\n        _onConnectionError: function(){\n            this.trigger('connection:error', this);\n        },\n\n        refresh: function(){\n            this.getConnection().refresh();\n        },\n\n        open: function(){\n            this.getConnection().open();\n        },\n\n        isConnected: function(){\n            return this.getConnection().isConnected();\n        },\n\n        _collaborationStatus: null,\n        getCollaborationStatus: function(){\n            if(!this.isConnected()){\n                return null;\n            }\n            if(this._collaborationStatus === null){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'getconnectionstatus'\n                    }\n                };\n                this.getConnection().send(message, function(response){\n                    logger.info('collaboration status', response);\n                    var connected = response.connected || {};\n                    if(connected.collaboration && connected.collaboration.length > 0){\n                        this._collaborationStatus = 'connected';\n                        this._countCollaborations = response.connected.collaboration.length;\n                        this._ready = true;\n                        this.trigger('ready', this);\n                        this.trigger('collaboration:' + this._collaborationStatus, this);\n                    }\n                }.bind(this));\n            }\n            return this._collaborationStatus;\n        },\n\n        getVersion: function(name, force){\n            if(!this.isConnected()){\n                return null;\n            }\n\n            if(this._version === null || force){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'getversion'\n                    }\n                };\n                this.getConnection().send(message, function(response){\n                    if(response && response.wiservice){\n                        this._version = response;\n                        this.getCollaborationStatus();\n                    }\n                }.bind(this));\n            }\n\n            if(name){\n                if(this._version && this._version.hasOwnProperty(name) && this._version[name]){\n                    return this._version[name];\n                }\n                return null;\n            }\n            return this._version;\n        }\n    });\n\n    return IntegrationService;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./IntegrationService.js\n// module id = 3\n// module chunks = 0 1","/**\n * @class Chat\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('IntegrationService'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Chat');\n\n    IntegrationService.addModule('Chat', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n        },\n\n        open: function(number){\n            var message = {\n                'msgdata': {\n                    'type': 'chat',\n                    'number': number\n                }\n            };\n            this._connection.send(message);\n        }\n\n    }));\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Chat.js\n// module id = 4\n// module chunks = 0 1","/**\n * @class Roster\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('IntegrationService'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Roster');\n\n    IntegrationService.addModule('Roster', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n            this._integrationService.on('collaboration:connected', this._onConnectedCollaboration, this);\n        },\n\n        _bindEvents: function(){\n            logger.info('_bindEvents');\n            this._integrationService.on('setroster', this._onSetRoster, this);\n            this._integrationService.on('updateuser', this._onUpdateUser, this);\n            this._integrationService.on('removeuser', this._onRemoveUser, this);\n            this._integrationService.on('adduser', this._onAddUser, this);\n        },\n\n        _roster: null,\n\n        getRoster: function(){\n            return this._roster;\n        },\n\n        _subscribed: false,\n        isSubscribed: function(){\n            return this._subscribed;\n        },\n\n        _needSubscribe: false,\n        subscribe: function(){\n            this._needSubscribe = true;\n            if(this._integrationService.isReady()){\n                // if need subscribe and collaboration connected\n                // need send subscription\n                this._subscribe();\n            }\n        },\n\n        _subscribe: function(){\n            if(this._needSubscribe){\n                logger.info('Send subscription');\n\n                if(!this._subscribed){\n                    // if first subscribe\n                    this._bindEvents();\n                }\n\n                this._subscribed = true;\n\n                var message = {\n                    'msgdata': {\n                        'type': 'subscribe',\n                        'event': 'roster'\n                    }\n                };\n\n                this._connection.send(message);\n            }\n        },\n\n        _sort: function(){\n            this._roster.sort(function compare(a, b){\n                return a.name.localeCompare(b.name);\n            });\n        },\n\n        _find: function(item){\n            var index = -1;\n            for(var i = 0; i < this._roster.length; i++){\n                if(this._roster[i].id == item.id){\n                    index = i;\n                    break;\n                }\n            }\n            return index;\n        },\n\n        _onConnectedCollaboration: function(){\n            this._subscribe();\n        },\n\n        _onSetRoster: function(event, roster){\n            logger.info('Received roster:', roster);\n\n            var isFirst = (this._roster === null);\n\n            this._roster = roster;\n            this._sort();\n\n            if(isFirst){\n                this.trigger('ready', this);\n            }\n\n            this.trigger('reset', this._roster);\n        },\n\n        _onUpdateUser: function(event, user){\n            logger.info('Update user:', user);\n            if(user && this._roster.length > 0){\n                var index = this._find(user);\n                if(index >= 0){\n                    this._roster[index] = user;\n                    this.trigger('update', user);\n                }\n            }\n        },\n\n        _onRemoveUser: function(event, user){\n            logger.info('Removed user:', user);\n            if(user && this._roster.length > 0){\n                var index = this._find(user);\n                if(index >= 0){\n                    this._roster.splice(index, 1);\n                    this.trigger('delete', user);\n                }\n            }\n        },\n\n        _onAddUser: function(event, user){\n            logger.info('Added user:', user);\n            if(user){\n                var index = this._find(user);\n                if(index == -1){\n                    this._roster.push(user);\n                    this._sort();\n                    this.trigger('add', user);\n                }\n            }\n        }\n    }));\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Roster.js\n// module id = 5\n// module chunks = 0 1","/**\n * @class Telephony\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('IntegrationService'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['IntegrationService', 'EventEmitter'], factory);\n    } else if (typeof IntegrationService !== 'undefined' && typeof EventEmitter !== 'undefined'){\n        // Browser\n        root.Connector = factory(IntegrationService, EventEmitter);\n    }\n}(this, function (IntegrationService, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Telephony');\n\n    IntegrationService.addModule('Telephony', extend({}, EventEmitter, {\n\n        _integrationService: null,\n        _connection: null,\n\n        initialize: function(IS){\n            logger.info('Initialize');\n\n            this._integrationService = IS;\n            this._connection = this._integrationService.getConnection();\n            this._integrationService.on('collaboration:connected', this._onConnectedCollaboration, this);\n        },\n\n        call: function(number, callback){\n            var message = {\n                'msgdata': {\n                    'type': 'call',\n                    'number': number\n                }\n            };\n            this._connection.send(message, callback);\n        },\n\n        _bindEvents: function(){\n            logger.info('_bindEvents');\n            this._integrationService.on('setcalls', this._onSetCalls, this);\n            this._integrationService.on('updatecall', this._onUpdateCall, this);\n            this._integrationService.on('removecall', this._onRemoveCall, this);\n            this._integrationService.on('addcall', this._onAddCall, this);\n        },\n\n        _calls: null,\n\n        getCalls: function(){\n            return this._calls;\n        },\n\n        _subscribed: false,\n        isSubscribed: function(){\n            return this._subscribed;\n        },\n\n        _needSubscribe: false,\n        subscribe: function(){\n            this._needSubscribe = true;\n            if(this._integrationService.isReady()){\n                // if need subscribe and collaboration connected\n                // need send subscription\n                this._subscribe();\n            }\n        },\n\n        _subscribe: function(){\n            if(this._needSubscribe){\n                logger.info('Send subscription');\n\n                if(!this._subscribed){\n                    // if first subscribe\n                    this._bindEvents();\n                }\n\n                this._subscribed = true;\n\n                var message = {\n                    'msgdata': {\n                        'type': 'subscribe',\n                        'event': 'calls'\n                    }\n                };\n\n                this._connection.send(message);\n            }\n        },\n\n        _find: function(item){\n            var index = -1;\n            for(var i = 0; i < this._calls.length; i++){\n                if(this._calls[i].channel == item.channel){\n                    index = i;\n                    break;\n                }\n            }\n            return index;\n        },\n\n        _onConnectedCollaboration: function(){\n            this._subscribe();\n        },\n\n        _onSetCalls: function(event, calls){\n            logger.info('Received calls:', calls);\n\n            var isFirst = (this._calls === null);\n\n            this._calls = calls;\n\n            if(isFirst){\n                this.trigger('ready', this);\n            }\n\n            this.trigger('reset', this._calls);\n        },\n\n        _onUpdateCall: function(event, call){\n            logger.info('Update call:', call);\n            if(call && this._calls.length > 0){\n                var index = this._find(call);\n                if(index >= 0){\n                    this._calls[index] = call;\n                    this.trigger('update', call);\n                }\n            }\n        },\n\n        _onRemoveCall: function(event, call){\n            logger.info('Removed call:', call);\n            if(call && this._calls.length > 0){\n                var index = this._find(call);\n                if(index >= 0){\n                    this._calls.splice(index, 1);\n                    this.trigger('delete', call);\n                }\n            }\n        },\n\n        _onAddCall: function(event, call){\n            logger.info('Added call:', call);\n            if(call){\n                var index = this._find(call);\n                if(index == -1){\n                    this._calls.push(call);\n                    this.trigger('add', call);\n                }\n            }\n        }\n    }));\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Telephony.js\n// module id = 6\n// module chunks = 0 1","/**\n * @class Connector\n */\n\n(function universalModuleDefinition(root, factory){\n    if (typeof exports == 'object'){\n        // CommonJS\n        module.exports = factory(require('ReconnectingWebSocket'), require('EventEmitter'));\n    } else if (typeof define == 'function' && define.amd){\n        // AMD\n        define(['ReconnectingWebSocket', 'EventEmitter'], factory);\n    } else if (typeof ReconnectingWebSocket !== 'undefined' && typeof ReconnectingWebSocket !== 'undefined'){\n        // Browser\n        root.Connector = factory(ReconnectingWebSocket, EventEmitter);\n    }\n}(this, function (ReconnectingWebSocket, EventEmitter){\n    'use strict';\n    var logger = Logger.get('Connector');\n\n    function Connector(options){\n        this.initialize(options);\n    }\n\n    extend(Connector.prototype, EventEmitter, {\n\n        _options: {\n            debug: false,\n            automaticOpen: true,\n            reconnectInterval: 1000,\n            maxReconnectInterval: 5000,\n            reconnectDecay: 1,\n            timeoutInterval: 3000,\n            maxReconnectAttempts: 1\n        },\n\n        _authData: null,\n\n        _connection: null,\n        _requestsCallback: {},\n\n        _isInstalled: false,\n        _isConnected: false,\n        _isAuthorized: false,\n\n        _requestTimeout: 120000,\n        _requestTimer: null,\n\n        _currentDefaultPortIndex: 0,\n        _defaultPort: [8888, 8889, 8890],\n\n        initialize: function(options){\n            logger.info('Initialize', options);\n\n            extend(this._options, options);\n\n            var port = window.localStorage.getItem('Wildix.IntegrationService.Port');\n            if(port){\n                this.getConnection(port);\n            }else{\n                this.getConnection();\n            }\n        },\n\n        getConnection: function(port) {\n            if(!port){\n                port = this._defaultPort[this._currentDefaultPortIndex];\n            }\n            if(this._connection === null){\n                var host = 'wss://wildixintegration.eu:' + port + '/';\n                this._connection = new ReconnectingWebSocket(host, null, this._options);\n\n                this._connection.onconnecting = this._onConnectingWS.bind(this);\n                this._connection.onopen = this._onOpenWS.bind(this);\n                this._connection.onerror = this._onErrorWS.bind(this);\n                this._connection.onmessage = this._onMessageWS.bind(this);\n                this._connection.onclose = this._onCloseWS.bind(this);\n            }\n            return this._connection;\n        },\n\n        setAuthData: function(data){\n            this._authData = data;\n        },\n\n        abort: function(){\n            this._connection.onconnecting = function(event) {};\n            this._connection.onopen = function(event) {};\n            this._connection.onerror = function(event) {};\n            this._connection.onmessage = function(event) {};\n            this._connection.onclose = function(event) {};\n\n            this._connection.close();\n            this._connection = null;\n\n            this._isConnected = false;\n            this._isAuthorized = false;\n        },\n\n        isInstalled: function() {\n            return this._isInstalled;\n        },\n\n        isConnected: function() {\n            return this._isConnected;\n        },\n\n        isAuthorized: function() {\n            return this._isAuthorized;\n        },\n\n        isReady: function(){\n            if(this.isInstalled() && this.isConnected() && this.isAuthorized()){\n                return true;\n            }\n            return false;\n        },\n\n        refresh: function(){\n            this.getConnection().refresh();\n        },\n\n        open: function(){\n            this.getConnection().open();\n        },\n\n        send: function(message, callback, timeout) {\n            if(!this.isConnected()){\n                return;\n            }\n            if(!message){\n                return;\n            }\n            if(!message.hasOwnProperty('message')){\n                message = extend({}, {\n                    message: 'E_' + this._authData.app\n                }, message);\n            }\n\n            if(!message.hasOwnProperty('id')){\n                message.id = this._generateID();\n            }\n\n            if(callback){\n                if(timeout === null || typeof timeout === 'undefined' || timeout < 0){\n                    timeout = this._requestTimeout;\n                }\n                this._requestsCallback[message.id] = {\n                    callback: callback,\n                    message: message,\n                    timeoutAt: Date.now() + timeout\n                };\n\n                this._checkRequestTimeout();\n            }\n\n            var requestString = JSON.stringify(message);\n\n            return this.getConnection().send(requestString);\n        },\n\n        _getCurrentPort: function(){\n            return this._connection.url.match(/[^\\d]+(\\d+).*/)[1];\n        },\n\n        _currentCandidat: -1,\n        _connectToNextCandidat: function(){\n            this._currentCandidat++;\n\n            this._getCandidates(function(candidates){\n                if(candidates[this._currentCandidat]){\n                    this.abort();\n                    this.getConnection(candidates[this._currentCandidat]);\n                }else{\n                    this.abort();\n                    this._currentCandidat = 0;\n                    this._candidates = null;\n                }\n            }.bind(this));\n        },\n\n        _candidates: null,\n        _getCandidates: function(callback){\n            callback = callback || function(){};\n\n            if(this._candidates === null){\n                var message = {\n                    'message': 'M_WISERVICE',\n                    'msgdata': {\n                        'command': 'candidates'\n                    }\n                };\n\n                this.send(message, function(response){\n                    if(response && response.candidates){\n                        this._candidates = response.candidates;\n                        callback(this._candidates);\n                    }\n                }.bind(this));\n            }else{\n                callback(this._candidates);\n            }\n        },\n\n        _autorize: function(){\n            if(!this.isConnected()){\n                return null;\n            }\n\n            if(!this._authData){\n                return null;\n            }\n\n            var message = {\n                'message': 'M_WISERVICE',\n                'msgdata': {\n                    'command': 'authorize',\n                    'msgdata': this._authData\n                }\n            };\n            this.send(message, function(response){\n                if(response && response.status && response.status == 'rejected'){\n                    logger.info('authorization rejected', response);\n                    this._connectToNextCandidat();\n                }else{\n                    window.localStorage.setItem('Wildix.IntegrationService.Port', this._getCurrentPort());\n                    this._isAuthorized = true;\n                    this._ready();\n                }\n            }.bind(this));\n        },\n\n        _ready: function(){\n            this.trigger('ready', this);\n        },\n\n        _checkRequestTimeout: function(){\n            if (!this._requestTimer){\n                this._requestTimer = setInterval(function(){\n                    for (var messageId in this._requestsCallback){\n                        if (this._requestsCallback.hasOwnProperty(messageId)){\n                            var request = this._requestsCallback[messageId];\n                            if (request.timeoutAt && request.timeoutAt <= Date.now()){\n                                this.trigger('requesttimeout', request);\n                                delete this._requestsCallback[messageId];\n                            }\n                        }\n                    }\n                }.bind(this), 100);\n            }\n        },\n\n        _generateID: function(len) {\n            if(!len){\n                len = 32;\n            }\n            var text = '';\n            var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n            for(var i = 0; i < len; i++) {\n                text += possible.charAt(Math.floor(Math.random() * possible.length));\n            }\n\n            return text;\n        },\n\n        _onConnectingWS: function(event) {\n            this._isConnected = false;\n            this.trigger('connecting', this);\n        },\n\n        _onOpenWS: function(event) {\n            this._isInstalled = true;\n            this._isConnected = true;\n            this.getConnection().maxReconnectAttempts = null;\n            this.trigger('connected', this);\n            this._autorize();\n        },\n\n        _onErrorWS: function(event, dd) {\n            if(this._candidates === null && this._defaultPort[this._currentDefaultPortIndex + 1]){\n                // if first connected and have next default port\n                if(this._getCurrentPort() == this._defaultPort[this._currentDefaultPortIndex]){\n                    // if port is default, then connect to the next default port\n                    this._currentDefaultPortIndex++;\n                }\n                this.abort();\n                this.getConnection();\n            }else{\n                this.abort();\n                this.trigger('error', this);\n            }\n        },\n\n        _onMessageWS: function(event) {\n            var message = null;\n            if(event.hasOwnProperty('data') && event.data){\n                try{\n                    message = JSON.parse(event.data);\n                }catch(e){\n                    logger.error('Bad message', e);\n                }\n            }\n            if(message && message.hasOwnProperty('message')){\n                switch (message.message.substr(0, 2)) {\n                    case 'E_': message.type = 'event';\n                        break;\n                    case 'R_': message.type = 'response';\n                        break;\n                    case 'C_': message.type = 'chunked';\n                        break;\n                    default: message.type = 'message';\n                        break;\n                }\n\n                message.application = message.message.substr(2);\n                message.application = message.application.toLowerCase();\n            }\n\n            if(message && message.hasOwnProperty('id')){\n                if(message.type == 'response' && this._requestsCallback.hasOwnProperty(message.id)){\n                    if(this._requestsCallback[message.id].hasOwnProperty('callback')){\n                        this._requestsCallback[message.id].callback(message.msgdata);\n                    }\n                    delete this._requestsCallback[message.id];\n                }\n            }\n\n            this.trigger(message.type + ':' + message.application, message);\n        },\n\n        _onCloseWS: function(event) {\n            if(this._isConnected){\n                this._isConnected = false;\n                logger.error('WS closed', event);\n                this.trigger('close', this);\n            }\n        }\n    });\n\n    return Connector;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./Connector.js\n// module id = 7\n// module chunks = 0 1","/*\n * entry point\n */\n\nrequire('Roster');\nrequire('Chat');\nrequire('Telephony');\n\nif (typeof exports == 'object'){\n    module.exports = require('IntegrationService');\n}else{\n    require('IntegrationService');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 8\n// module chunks = 0 1","// MIT License:\n//\n// Copyright (c) 2010-2012, Joe Walnes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * This behaves like a WebSocket in every way, except if it fails to connect,\n * or it gets disconnected, it will repeatedly poll until it successfully connects\n * again.\n *\n * It is API compatible, so when you have:\n *   ws = new WebSocket('ws://....');\n * you can replace with:\n *   ws = new ReconnectingWebSocket('ws://....');\n *\n * The event stream will typically look like:\n *  onconnecting\n *  onopen\n *  onmessage\n *  onmessage\n *  onclose // lost connection\n *  onconnecting\n *  onopen  // sometime later...\n *  onmessage\n *  onmessage\n *  etc...\n *\n * It is API compatible with the standard WebSocket API, apart from the following members:\n *\n * - `bufferedAmount`\n * - `extensions`\n * - `binaryType`\n *\n * Latest version: https://github.com/joewalnes/reconnecting-websocket/\n * - Joe Walnes\n *\n * Syntax\n * ======\n * var socket = new ReconnectingWebSocket(url, protocols, options);\n *\n * Parameters\n * ==========\n * url - The url you are connecting to.\n * protocols - Optional string or array of protocols.\n * options - See below\n *\n * Options\n * =======\n * Options can either be passed upon instantiation or set after instantiation:\n *\n * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });\n *\n * or\n *\n * var socket = new ReconnectingWebSocket(url);\n * socket.debug = true;\n * socket.reconnectInterval = 4000;\n *\n * debug\n * - Whether this instance should log debug messages. Accepts true or false. Default: false.\n *\n * automaticOpen\n * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().\n *\n * reconnectInterval\n * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.\n *\n * maxReconnectInterval\n * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.\n *\n * reconnectDecay\n * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.\n *\n * timeoutInterval\n * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.\n *\n */\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof module !== 'undefined' && module.exports){\n        module.exports = factory();\n    } else {\n        global.ReconnectingWebSocket = factory();\n    }\n})(this, function () {\n\n    if (!('WebSocket' in window)) {\n        return;\n    }\n\n    function ReconnectingWebSocket(url, protocols, options) {\n\n        // Default settings\n        var settings = {\n\n            /** Whether this instance should log debug messages. */\n            debug: false,\n\n            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */\n            automaticOpen: true,\n\n            /** The number of milliseconds to delay before attempting to reconnect. */\n            reconnectInterval: 1000,\n            /** The maximum number of milliseconds to delay a reconnection attempt. */\n            maxReconnectInterval: 30000,\n            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */\n            reconnectDecay: 1.5,\n\n            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */\n            timeoutInterval: 2000,\n\n            /** The maximum number of reconnection attempts to make. Unlimited if null. */\n            maxReconnectAttempts: null\n        }\n        if (!options) { options = {}; }\n\n        // Overwrite and define settings with options if they exist.\n        for (var key in settings) {\n            if (typeof options[key] !== 'undefined') {\n                this[key] = options[key];\n            } else {\n                this[key] = settings[key];\n            }\n        }\n\n        // These should be treated as read-only properties\n\n        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */\n        this.url = url;\n\n        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */\n        this.reconnectAttempts = 0;\n\n        /**\n         * The current state of the connection.\n         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED\n         * Read only.\n         */\n        this.readyState = WebSocket.CONNECTING;\n\n        /**\n         * A string indicating the name of the sub-protocol the server selected; this will be one of\n         * the strings specified in the protocols parameter when creating the WebSocket object.\n         * Read only.\n         */\n        this.protocol = null;\n\n        // Private state variables\n\n        var self = this;\n        var ws;\n        var forcedClose = false;\n        var timedOut = false;\n        var eventTarget = document.createElement('div');\n\n        // Wire up \"on*\" properties as event handlers\n\n        eventTarget.addEventListener('open',       function(event) { self.onopen(event); });\n        eventTarget.addEventListener('close',      function(event) { self.onclose(event); });\n        eventTarget.addEventListener('connecting', function(event) { self.onconnecting(event); });\n        eventTarget.addEventListener('message',    function(event) { self.onmessage(event); });\n        eventTarget.addEventListener('error',      function(event) { self.onerror(event); });\n\n        // Expose the API required by EventTarget\n\n        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);\n        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);\n        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);\n\n        /**\n         * This function generates an event that is compatible with standard\n         * compliant browsers and IE9 - IE11\n         *\n         * This will prevent the error:\n         * Object doesn't support this action\n         *\n         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563\n         * @param s String The name that the event should use\n         * @param args Object an optional object that the event will use\n         */\n        function generateEvent(s, args) {\n        \tvar evt = document.createEvent(\"CustomEvent\");\n        \tevt.initCustomEvent(s, false, false, args);\n        \treturn evt;\n        };\n\n        this.open = function (reconnectAttempt) {\n            ws = new WebSocket(self.url, protocols || []);\n\n            if (reconnectAttempt) {\n                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {\n                    return;\n                }\n            } else {\n                eventTarget.dispatchEvent(generateEvent('connecting'));\n                this.reconnectAttempts = 0;\n            }\n\n            if (self.debug || ReconnectingWebSocket.debugAll) {\n                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);\n            }\n\n            var localWs = ws;\n            var timeout = setTimeout(function() {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);\n                }\n                timedOut = true;\n                localWs.close();\n                timedOut = false;\n            }, self.timeoutInterval);\n\n            ws.onopen = function(event) {\n                clearTimeout(timeout);\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onopen', self.url);\n                }\n                self.protocol = ws.protocol;\n                self.readyState = WebSocket.OPEN;\n                self.reconnectAttempts = 0;\n                var e = generateEvent('open');\n                e.isReconnect = reconnectAttempt;\n                reconnectAttempt = false;\n                eventTarget.dispatchEvent(e);\n            };\n\n            ws.onclose = function(event) {\n                clearTimeout(timeout);\n                ws = null;\n                if (forcedClose) {\n                    self.readyState = WebSocket.CLOSED;\n                    eventTarget.dispatchEvent(generateEvent('close'));\n                } else {\n                    self.readyState = WebSocket.CONNECTING;\n                    var e = generateEvent('connecting');\n                    e.code = event.code;\n                    e.reason = event.reason;\n                    e.wasClean = event.wasClean;\n                    eventTarget.dispatchEvent(e);\n                    if (!reconnectAttempt && !timedOut) {\n                        if (self.debug || ReconnectingWebSocket.debugAll) {\n                            console.debug('ReconnectingWebSocket', 'onclose', self.url);\n                        }\n                        eventTarget.dispatchEvent(generateEvent('close'));\n                    }\n\n                    var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);\n                    setTimeout(function() {\n                        self.reconnectAttempts++;\n                        self.open(true);\n                    }, timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout);\n                }\n            };\n            ws.onmessage = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onmessage', self.url, event.data);\n                }\n                var e = generateEvent('message');\n                e.data = event.data;\n                eventTarget.dispatchEvent(e);\n            };\n            ws.onerror = function(event) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);\n                }\n                eventTarget.dispatchEvent(generateEvent('error'));\n            };\n        }\n\n        // Whether or not to create a websocket upon instantiation\n        if (this.automaticOpen == true) {\n            this.open(false);\n        }\n\n        /**\n         * Transmits data to the server over the WebSocket connection.\n         *\n         * @param data a text string, ArrayBuffer or Blob to send to the server.\n         */\n        this.send = function(data) {\n            if (ws) {\n                if (self.debug || ReconnectingWebSocket.debugAll) {\n                    console.debug('ReconnectingWebSocket', 'send', self.url, data);\n                }\n                return ws.send(data);\n            } else {\n                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';\n            }\n        };\n\n        /**\n         * Closes the WebSocket connection or connection attempt, if any.\n         * If the connection is already CLOSED, this method does nothing.\n         */\n        this.close = function(code, reason) {\n            // Default CLOSE_NORMAL code\n            if (typeof code == 'undefined') {\n                code = 1000;\n            }\n            forcedClose = true;\n            if (ws) {\n                ws.close(code, reason);\n            }\n        };\n\n        /**\n         * Additional public API method to refresh the connection if still open (close, re-open).\n         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.\n         */\n        this.refresh = function() {\n            if (ws) {\n                ws.close();\n            }\n        };\n    }\n\n    /**\n     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n     * this indicates that the connection is ready to send and receive data.\n     */\n    ReconnectingWebSocket.prototype.onopen = function(event) {};\n    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */\n    ReconnectingWebSocket.prototype.onclose = function(event) {};\n    /** An event listener to be called when a connection begins being attempted. */\n    ReconnectingWebSocket.prototype.onconnecting = function(event) {};\n    /** An event listener to be called when a message is received from the server. */\n    ReconnectingWebSocket.prototype.onmessage = function(event) {};\n    /** An event listener to be called when an error occurs. */\n    ReconnectingWebSocket.prototype.onerror = function(event) {};\n\n    /**\n     * Whether all instances of ReconnectingWebSocket should log debug messages.\n     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.\n     */\n    ReconnectingWebSocket.debugAll = false;\n\n    ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;\n    ReconnectingWebSocket.OPEN = WebSocket.OPEN;\n    ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;\n    ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;\n\n    return ReconnectingWebSocket;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/reconnectingwebsocket/reconnecting-websocket.js\n// module id = 9\n// module chunks = 0 1"],"sourceRoot":""}